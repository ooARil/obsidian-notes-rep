LiquiBase - это инструмент для управления изменениями баз данных. Он позволяет разработчикам управлять изменениями в базе данных, используя файлы изменений, которые могут быть проверены в системе управления версиями.

LiquiBase используется для следующих целей:

1. Управление изменениями баз данных: LiquiBase позволяет разработчикам управлять изменениями в базе данных, используя файлы изменений, которые могут быть проверены в системе управления версиями. Это позволяет командам разработчиков совместно работать над базой данных, не мешая друг другу.
    
2. Автоматизация процесса развертывания: LiquiBase может автоматизировать процесс развертывания изменений в базе данных, что позволяет разработчикам быстро и эффективно развертывать изменения в рабочей среде.
    
3. Поддержка различных типов баз данных: LiquiBase поддерживает различные типы баз данных, включая Oracle, MySQL, PostgreSQL, SQL Server, H2, HyperSQL, Derby, HSQLDB, Firebird, DB2, MSSQL, Sybase и SQLite.
    
4. Поддержка различных платформ: LiquiBase может работать на различных платформах, включая Windows, Linux и Mac OS.
    
5. Поддержка различных языков программирования: LiquiBase поддерживает различные языки программирования, включая Java, .NET, Ruby, Python и Node.js.

---

### Как работает LiquiBase?

Схема:
![[Pasted image 20240424003351.png]]
Пояснение:
- databasechangeloglock - служит для управления доступом к базе данных при выполнении изменений. Она используется для предотвращения одновременного доступа к базе данных из нескольких экземпляров LiquiBase, что может привести к конфликтам и ошибкам.
	 содержит следующие столбцы:
	- `ID`: Уникальный идентификатор блокировки. В большинстве случаев это будет равно 1.
	- `LOCKED`: Флаг, указывающий, занята ли блокировка. Если `LOCKED` равен 1, блокировка занята, и LiquiBase должен подождать, пока она не будет освобождена. Если `LOCKED` равен 0, блокировка свободна, и LiquiBase может получить ее.
	- `LOCKGRANTED`: Время, когда блокировка была предоставлена.
	- `LOCKEDBY`: Идентификатор экземпляра LiquiBase, который получил блокировку.

- databasechangelog -  служит для для отслеживания изменений, примененных к базе данных. Она хранит историю всех изменений, которые были применены к базе данных, включая дату, время, пользователя, который внес изменения, и описание каждого изменения.
	содержит следующие столбцы:
	- `ID`: Уникальный идентификатор изменения.
    - `AUTHOR`: Имя пользователя, который внес изменение.
	- `FILENAME`: Имя файла, в котором определено изменение.  
	- `DATEEXECUTED`: Дата и время применения изменения.
	- `ORDEREXECUTED`: Порядок применения изменения.
	- `EXECTYPE`: Тип выполнения изменения (например, `EXECUTED`, `SKIPPED`, `FAILED`).
	- `MD5SUM`: Контрольная сумма файла изменения.
	- `DESCRIPTION`: Описание изменения.
	- `COMMENTS`: Дополнительные комментарии к изменению.
	- `TAG`: Тег, связанный с изменением.
	- `LIQUIBASE`: Версия LiquiBase, использовавшаяся для применения изменения.
	- `CONTEXTS`: Контексты, в которых применялось изменение.
	- `LABELS`: Метки, связанные с изменением.
	- `DEPLOYMENT_ID`: Идентификатор развертывания, связанный с изменением.
	`databasechangelog` позволяет LiquiBase отслеживать, какие изменения уже были применены к базе данных, что помогает предотвратить повторное применение изменений и обеспечивает целостность истории изменений в базе данных.

Алгоритм:
1. Сначала liquibase отправляет запрос для того, чтобы залочить запуск наших migration-скриптов:
	![[Pasted image 20240424004602.png]]
	и т.е. никакой другой процесс не сможет накатывать одновременно скрипты миграции, если таблица databasechangeloglock была залочена (LOCKED = TRUE).

	Пояснение: Это требуется для того, потому что в реальных приложениях, у нас может существовать несколько инстансов одного и того же приложения, а значит каждый из них захочет накатить скрипты миграции (потому что обычно все скрипты миграции описаны в рамках приложения). 
	Поэтому для того, чтобы параллельно не накатывать одинаковые изменения (или даже разные изменения) на базу данных, мы должны заблокировать процесс для остальных инстансов (по аналогии работают шедулеры на нескольких инстансах), - и благодаря этому один инстанс в один момент времени будет накатывать скрипты миграции.

2. После того как получилось захватить perssimistic lock (т.е. databasechangeloglock таблицу) мы начинаем отслеживать таблицу databasechangelog:

	SQL-скрипт = одна запись в таблицe databasechangelog = changeset ([[#Основные понятия LiquiBase]])

	![[Pasted image 20240424005359.png]]
	И перед тем как выполнить наш SQL-скрипт миграции, luquibase проверяет такие поля как id, author и filename. Они представляют из себя что-то вроде составного первичного ключа ("вроде" - потому что в DDL нету инфы о первичном ключе).

	И liquibase проверяет, если по такому первичному ключу (в нашем случае `'Tue Apr 23 16:30:00 MSK 2024', 'ailinskii', 'db/changelog/db.changelog-0.0.1.yaml'`)  еще не было записи в databasechangelog таблице, то он выполнит наш запрос и сделает INSERT INTO (запись) в databasechangelog - то что наш SQL-скрипт был выполнен.
	![[Pasted image 20240424004406.png]]

	Пояснение: А если же такая запись (SQL-скрпит) уже была, то такая запись (SQL-скрипт) игнорируется и повторно не записывается в databasechangelog.

	Также одно из самых важных полей в таблице - это чек-сумма SQL-скрипта, она нужна для того, что проверить, что наши запросы не были изменены, после того как уже были записаны в таблицу databasechangelog ([[#md5sum (чек-сумма SQL-скрипта)]]).
	
	Пояснение: Поэтому чтобы изменить существующий SQL-скрипт, который уже был выполнен и занесен в databasechangelog, необходимо создать еще один SQL-скрипт, который исправляет предыдущий, и он будет также записан в таблицу databasechangelog без каких-либо конфликтов

3. После того как changelog ([[#Основные понятия LiquiBase]]) выполнил все changeset ([[#Основные понятия LiquiBase]]), снимается lock с таблицы databasechangeloglock:
	![[Pasted image 20240424020016.png]]

---

### md5sum (чек-сумма SQL-скрипта)

Также важным полем в таблице databasechangelog является `md5sum` - это чек-сумма (по факту просто hash-функция) нашего SQL-скрипта. 

Т.е. если мы изменим уже существующий SQL-скрипт, который уже накачен (т.е. уже есть запись в таблице databasechangelog, - т.е. уже есть такой id, author и filename), то `md5sum` не совпадет - и luquibase поймет, что мы изменили существующий накаченный SQL-скрипт и выбросит исключение.

Потому что изменять SQL-скрипты после накатывания нельзя!!!

скрипты = одна запись в таблице databasechangelog = changeset ([[#Основные понятия LiquiBase]])

---

### Основные понятия LiquiBase

![[Pasted image 20240424011350.png]]
Пояснение:
- changelog - это файл, который содержит список изменений (список changset-ов), внесенных в базу данных или другой набор данных. Т.е. один большой SQL-скрипт (список changset-ов), который мы должны выполнить и накатить на базу данных:
	Может быть представлен в виде 4-х основных форматах (как раз-таки на него открывается lock в таблице databasechangeloglock):
	- SQL:
		![[Pasted image 20240424013558.png]]
	- XML:
		![[Pasted image 20240424013654.png]]
	* YAML:
		![[Pasted image 20240424013956.png]]
	- JSON

- changeset - состоит из одного или нескольких SQL-запросов, которые должны быть выполнены в одной транзакции.
	![[Pasted image 20240424014453.png]]
	Замечание: Как раз таки можно увидеть id, author и filename:
	![[Pasted image 20240424015038.png]]
	Т.е. в таблицу databasechangelog у нас как раз записываются changeset-ы.

	Пояснение: SQL-скрипт:
		![[Pasted image 20240424014538.png]]

- change - это один SQL-запрос:
	![[Pasted image 20240424014622.png]]
	Пояснение: Т.к. change выполняются в рамках одной транкзации в changeset, то есть best-practise, - делать один change в одной транкзации (т.е. один change на changeset).
	Данный подход хорош тем, что можно делать красивый rollback ([[Конфигурация LiquiBase]]).

	Замечание: В моем случае в yaml файле это не так))) Т.к. создается 3 функции, т.е. это 3 change в рамках одного changeset (т.е. в рамках одной транзакции).


Т.к. changelog-ов может быть несколько, то необходимо их как-то аккумулировать (собирать):
![[Pasted image 20240424020206.png]]поэтому структура всех проектов, использующих liquibase следующая:
- changelog-master.yaml - у нас есть какой-то один changelog-файл, который содержит все остальные changelog-и (которые содержат changeset-ы с SQL-скриптами)
	![[Pasted image 20240424020414.png]]
	Пояснение: 
	- Он уже не может использоваться в SQL-формате, только в XML, YAML, JSON.
	- В changelog-master - мы просто указываем ссылки на другие changelog-и (`db/changelog/db.changelog-0.0.1.yaml`)

	Замечание:
	- Название changelog (не master) может быть любое (желательно, чтобы содержало номер версии - для соблюдения историчности)
		![[Pasted image 20240424020757.png]]
	- Название changelog-master должно быть конкретным и должно быть задано (либо использовать имя по-умолчанию) ([[Конфигурация LiquiBase]])