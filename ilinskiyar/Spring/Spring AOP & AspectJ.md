Spring AOP - работает только на бины
AspectJ - работает на все

---
### Создание aspectJ прокси - сложный кейс

Мой кейс:
- Класс находится в библиотеке Keycloak:
	![[Pasted image 20240623224737.png]]
- Не является бином - создается каждый раз:
	![[Pasted image 20240623224702.png]]

Решение:
1. Создал Aspect-класс:
	![[Pasted image 20240623224846.png]]

2. Подключил зависимости:
	![[Pasted image 20240623224917.png]]

3. Настроил плагин, который на этапе компиляции оборачивает наш AuthorizationResource в прокси KeycloakAuthorizationRequestAspect: 
	![[Pasted image 20240623225049.png]]
	Проблемы и решения:
	- Версия 1.14.0 - не работает с java 17. Т.к. внутри использует версию aspectJ (1.9.7), которая не поддерживает java 17.
		*Решение:*
		1. Указываю в блоке dependencies плагина, чтобы он использовал aspectj версии 1.9.20 (которая поддерживает java 17), вместо 1.9.7:
			![[Pasted image 20240623225250.png]]
			
		2. Указываю версию Java 17 (про это нужно лучше почитать):
			![[Pasted image 20240623225427.png]]

	- Пытается создать прокси для всех. По умолчанию данный плагин на этапе компиляции пытается создать прокси для всех объектов, на падает в ошибку:
		*Решение:*
		1. Указываю в блоке includes какие именно классы должны быть созданы с помощью AspectJ:
			![[Pasted image 20240623225611.png]]
			Пояснение: В includes должны быть указаны только classpath классы, и обязательно сам аспект-класс, и тот класс который указан в execuiton аспекта

		2. Т.к. AuthorizationResource относится к библиотеке Keycloak, он не может быть указан через classpath, поэтому нужно указать зависимость (который данный класс принадлежит) в связных зависимостях, чтобы Keycloak смогу брать оттуда классы для создания прокси.

4. AspectJ при компиляции не дружит с Lobmok (будет жаловать на private final и т.д.), поэтому в данном аспект-классе избавляемся от Lombok:
	![[Pasted image 20240623230117.png]]
	Замечание: Мб как-то можно решить, но пока хз

5. Если мы используем AspectJ, а не Spring AOP то мы не сможем просто пометить наш Aspect-класс аннотацией @Component и внедрить зависимость.
	![[Pasted image 20240623230229.png]]
	Пояснение: Бин создаться, но aspectJ использует другой подход, там для создания прокси используется `Aspects.aspectOf(KeycloakAuthorizationRequestAspect.class)`, и поэтому все внедренные зависимости будут null. 

	Замечание: Особо этим не проникался

	Чтобы внедрить зависимость, нужно создать наш Aspect-класс как бин, через `Aspects.of`:
	![[Pasted image 20240623230422.png]]
	таким образом наши зависимости будут внедрены.

	Пояснение: @Order стоит, чтобы данный бин создавался в самом конце, т.к. были конфликты при сборке (которые странно возникали - не разбирался, но @Order помог).


Алгоритм:
1. Собираем проект (или только clean compile) clean install:
	Если все хорошо, то увидем это в логах:
	![[Pasted image 20240623225936.png]]
	это означает что наш аспект был добавлен.

	Если видим другое сообщение, значит наш апсект не был создан, и упала ошибка

2. После чего запускаем приложение

ГЛАВНОЕ ПРАВИЛО:
- **Если поменяли что в aspect-классе, всегда пересобирайте проект, иначе будет падать ошибка!!!**

Работает прокси офигенно, даже когда у меня в сторонней библиотеке создается каждый раз объект, из-за такой настройки плагина он всегда создается как proxy:
![[Pasted image 20240623224702.png]]

Плюс гибкая настройка плагина, позволяет выбирать конкретные аспекты.