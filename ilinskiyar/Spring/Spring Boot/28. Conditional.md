Преимущество Spring Boot заключается в автоконфигурации, и динамиеческого подключения модулей на основании каких-либо условий [[27. Spring Boot - введение]]
![[Pasted image 20240420174559.png]]

И в этом механизме задействована аннотация @Conditional

---

### @Conditional

@Conditional - в Spring Framework используется для условного создания компонентов. Это позволяет определить условия, при которых бин или конфигурация должны быть созданы и зарегистрированы в контексте приложения.
![[Pasted image 20240420183753.png]]
Пояснение: Данная аннотация ставится как над типом, так и над методом (имеется в виду методы с аннотацией @Bean)

С помощью аннотации @Conditional мы можем включать/выключать бины/конфигурации по переданным Condition-классам в value (может быть массив таких классов), в которых описывается условие (добавлять данный бин/конфигурацию в Spring-контекст или нет):

Condition-классом является класс, которые реализует интерфейс Condition:
![[Pasted image 20240420184339.png]]
Пояснение: Condition - это функциональный интерфейс, который имеет единственный метод matсрes:
- *matсhes* -  содержит в себе проверку, результатом которой является boolean (true - добавлять бин/конфигурацию в контекст, false - не добавлять).

	Параметры метода *matches*:
	- ConditionContext - все необходимые данные по всему Spring-контексту.
	![[Pasted image 20240420184626.png]]
		Пояснение:
		- BeanDefinitionRegistry - все bean definition по которым будут созданы бины.
		- ConfigurableListableBeanFactory - все созданные бины.
		- Enviroment - с помощью него мы сможем получить доступ ко всем property, profiles и системным переменным.
		- ResourceLoader - используется для того, чтобы загружать различные ресурсы (т.е. любой файл в нашем classpath (например: property-файл, java-class))
		- ClassLoader - используется для того, чтобы загружать классы по их имени.

	- AnnotatedTypeMetadata - метаинформация по аннотации @Conditional, которая стоит над классом/методом (т.е. благодаря этому мы можем получить информацию о других аннотациях, которые стоят над данным классом или над данным методом):
	![[Pasted image 20240420185505.png]]


---

### Создание собственного Condition-класса

1. Создадим конфигурационный класс для подключения базы данных:
	![[Pasted image 20240420185656.png]]
	Пояснение: init() метод нужен, чтобы увидеть в логе, был ли создан бин этого класса.

2. Теперь создадим Condition-класс, который проверяет: был ли загружен класс "org.postgresql.Driver" в память (с помощью ClassLoader):
	![[Pasted image 20240420185933.png]]

3. Теперь над нашим конфигурационным классом вешаем аннотацию @Conditional и передаем в неё наш Condition-класс:
	![[Pasted image 20240420190058.png]]

В результате запуска, конечно, при попытке загрузить PostgreSQL Driver падает ошибка:
![[Pasted image 20240420190221.png]]
	поэтому наш бин класса JpaConfig не будет создан (т.к. Condition-класс вернул false):
	![[Pasted image 20240420190315.png]]

Но теперь подключим зависимость на PostgreSQL driver:
![[Pasted image 20240420190508.png]]
	и при повторном запуске удается загрузить PostreSQL driver:
	![[Pasted image 20240420190603.png]]
	и бин jpaConfig будет добавлен в контекст:
	![[Pasted image 20240420190657.png]]
	![[Pasted image 20240420190720.png]]


---

### Аннотация @Conditional используется в других аннотациях

Аннотация @Condfitional используется в аннотации @Profile [[25. Profiles]]:
![[Pasted image 20240420190851.png]]
	и в ней указан Condition-класс (ProfileCondition):
	![[Pasted image 20240420190931.png]]
	который делает следующее:
	 1. Как раз через metadata достает аннотацию @Profile
	 2. Достает из неё список её аргументов 
	 3. После чего берет аргумент `value` (в котором пишется имя профиля Spring-а)
	 4. И проверяет через Enviroment (который получает через context) совпадает ли установленный профиль в Spring-е c именем профиля указанном в value.
	 5. Если да, то возвращает true - и бин/конфигурация будет создан (как было видно в [[25. Profiles]]), иначе - не создает.

Таким образом мы можем создать свои аннотации, в которой будет указана аннотация @Conditional, - и она будет проверять нужно ли создавать бин/конфигурацию по конкретному Condition-классу.

И как раз, когда мы подключим spring-boot-starter (хотя бы один) [[27. Spring Boot - введение#Spring Boot Starters]], то у нас неявно добавится куча других Condition-классов, с помощью которых мы сможем включать/выключать конфигурации/бины динамически:
![[Pasted image 20240420191910.png]]
Пояснение: Как раз на основании classpath, propertirs, bean-ов и SpEL-а мы сможем включать/выключать бины/конфигурации, благодаря аннотациям с @Conditional которые с ними работают.