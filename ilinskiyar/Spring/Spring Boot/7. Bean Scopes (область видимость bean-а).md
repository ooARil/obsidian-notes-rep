Можно в дэбаге увидеть, что при создании бинов connectionPool и companyRepository
![[Pasted image 20240128163408.png]]
![[Pasted image 20240128163353.png]]
У нас создается только один объект connectionPool, т.е. он не пересоздается для companyRepository, т.е. по факту он является Singleton.

---

### Виды области видимости bean-ов

![[Pasted image 20240128170206.png]]Пояснение:
- *Common (ApplicationContext)* - (общее) все контексты, которые реализуют интерфейс ApplicationContext имеют следующие типы (т.е. например ClassPathXmlApplicationContext)
	- singleton - создается бин в единственном экзепляре.
	- prototype - создаются новый бин каждый раз, когда мы его пытаемся получить из контекста:
			![[Pasted image 20240128173504.png]]
	- thread (SimpleThreadScope) - т.е. по факту используется ThreadLocal, чтобы создавать бины для каждого нового потока (т.е. бин соответствует одному потоку).
		Пояснение: Т.е. если у нас 10 потоков, которые обращаются за одним и тем же бином из контекста, поэтому чтобы бин для каждого потока был новый, нужно зарегистрировать новый тип scope-а:
		![[Pasted image 20240128173820.png]]
		Замечание: Т.е. хоть этот scope и является общим, его нужно подключать самостоятельно.
- *Web (WebApplicationContext)* - контексты, которые помимо ApplicationContext еще реализуют интерфейс WebApplicationContex:
	- request - т.е. для каждого запроса по HTTP создается новый бин.
	- session - т.е. для каждой сессии создается новый бин.
	- application - т.е. на сервлет-контекст создается один бин.
	- websocket - т.е. для каждого сокета создается новый бин.
- *Custom* - создание собственных скоупов. Для этого требуется реализовать интерфейс *org.springframework.beans.factory.config.Scope* и зарегистрировать скоуп бина с помощью метода *ConfigurableBeanFactory.registerScope*:
	![[Pasted image 20240128173820.png]]

---

### Prototype

По-умолчанию созданные бины без указания конкретного скоупа являются Singleton, для того, что это исправить достаточно добавить значение элемент scope в тэг bean-а 
![[Pasted image 20240128182942.png]]
Таким образом, мы можем увидеть, что при обращении к этому бину, т.е. при попытке получить это бин из контекста (т.е. либо просто получить бин, либо если другой бин инжектит этот бин (например: companyRepository), будет каждый раз создаваться новый объект
![[Pasted image 20240128183032.png]]
![[Pasted image 20240128183056.png]]
![[Pasted image 20240128183045.png]]

---

### Кишки getBean или откуда тогда берется bean-синглтон, если bean-прототйап пересоздается?

В beanFactory присутствует ConcurrentHashMap singletonObject, где ключ - id бина, значение - созданный объект, и в этой мапе хранятся только singleton:
![[Pasted image 20240130021032.png]]
Пояснение: 
- Получается, поэтому когда мы вызываем метод getBean() у singleton, он берет значение бина, именно из этой мапы.
	Т.е. после того как были созданы бины (этап *beans*), они складываются в эту мапу.
		![[Pasted image 20240128160251.png]]
- В случае же prototype, они не хранятся в этой мапе, они создаются каждый раз.
	Т.е. после того как были созданы бины (этап *beans*), они не складываются в эту мапу, а просто отдаются.
		![[Pasted image 20240128160251.png]]