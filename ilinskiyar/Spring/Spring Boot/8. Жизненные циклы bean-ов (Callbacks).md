![[Pasted image 20240130021503.png]]Пояснение: Т.е. добавляются дополнительные этапы:
- *initialization callbacks* - вызов дополнительных методов обработки beanDefinition до их инициализации в бины:
	- *@PostConstruct* - предпочтительный способ вызова методов доп.обработки до создания бина через аннотацию.
	- *afterPropertySet() - интерфейс InitializingBean* - реализация интерфейса InitializingBean для определения логики в методе afterPropertySet. (нежелательно использовать)
	- *init-method* - через xml.
- *destruction callbacks* - т.е. вызов дополнительных методов обработки бина после его уничтожения (т.е. ЗАКРЫТИЯ (метод close()) контекста) (пример: т.е. очистка каких-то ресурсов)
	- *@PreDestroy* - предпочтительный способ через аннотации.
	- *destroy() - DisposableBean* - реализация интерфейся DisposableBean. (нежелательно использовать)
	- *destroy-method* - xml.
	Замечание:
	- destruction callback - работают только для singleton бинов, для prototype бинов они не вызваются.
	- destruction callback - вызываются только после ЗАКРЫТИЯ контекста, т.е. должен быть вызван метод close()!!! Иначе данные destroy-методы не будут вызваны и произойдет утечка памяти.

---

### Зачем нужен init-метод?

**Init-методы:**

- Init-метод вызывается после того, как все свойства бина были установлены и сам объект проинициализирован (через конструктор или фабричный метод), но перед тем, как бин будет предоставлен для использования.
- Это место, где вы можете выполнить дополнительные настройки, инициализацию ресурсов или установку значений по умолчанию.
- Но они применяются к конкретному бину!!!

---

### Интересные вещи про init-методы

1. все init-методы (т.е. @PostConstruct, afterPropertySet(), init-method xml) должны возвращать void и не принимать параметров, т.к. являются методами инициализации.
2. в одном классе можно указать сразу 3 способа вызова дополнительных методов:
	![[Pasted image 20240130024852.png]]
	И их последовательность выполнения, будет идти в таком же порядке как на картинке:
		![[Pasted image 20240130024934.png]]
		![[Pasted image 20240130024954.png]]
	Замечание: Однако если такое присутствует это говорит о плохой планировке кода.

---

### Пример init-method в xml

Для этого сначала определяем любой метод, который мы хотим вызывать до создания бина (но после вызова конструктора и сэттеров) (обычно его называют init):
![[Pasted image 20240130022948.png]]
А далее просто в тэг $<bean>$ добавляем элемент init-method, в который указываем название метода:
![[Pasted image 20240130023114.png]]
Замечание: intelji idea находит и подсказывает такие методы:
![[Pasted image 20240130023225.png]]
Также можно проследить цепочку вызовов:
![[Pasted image 20240130023338.png]]
![[Pasted image 20240130023344.png]]
Т.е. сначала создается конструктор, потом вызываются сэттеры, и только потом callback init - методы, - т.е. все соответствует жизненному циклу.

Также в beanFacotry -> beanDefinitionMap -> beanDefinition, можно увидеть, что в поле initMethodName добавилось наименование init-метода:
![[Pasted image 20240130023647.png]]
Замечание: Как мы можем увидеть, может быть только один init-метод, т.к. поле не является листом.

Замечание: Модификатор доступа таких методов может быть любой, т.к. используется Reflection API.

---

### Пример init-method c помощью реализации интерфейса InitializingBean

Для этого достаточно реализовать интерфейс IntialingBean и его метода afterPropertySet():
![[Pasted image 20240130025153.png]]

---

### Зачем нужен destroy-метод?

- Destroy-метод вызывается перед уничтожением бина, когда контейнер Spring закрывается или когда управляемый бин удаляется из контекста.
- Здесь можно выполнять освобождение ресурсов, закрытие соединений и т.д.
- Для конкретного бина!!!

---
### Интересные вещи про destroy-методы

1. все init-методы (т.е. @PreDestroy, destroy(), destroy-method xml) должны возвращать void и не принимать параметров.
2. в одном классе можно указать сразу 3 способа вызова дополнительных методов:
	![[Pasted image 20240130031610.png]]
	И их последовательность выполнения, будет идти в таком же порядке как на картинке:
		![[Pasted image 20240130031624.png]]
		![[Pasted image 20240130031647.png]]
	Замечание: Однако если такое присутствует это говорит о плохой планировке кода.

---
### Пример destroy-method в xml

Чтобы добавить destroy-метод, который обычно используется для освобождения ресурсов, то достаточно определить метод в классе:
![[Pasted image 20240130030302.png]]
И указать его в тэге $<bean>$ в xml:
![[Pasted image 20240130030330.png]]

Однако если запустить такое приложение, то мы увидим, что данный метод у нас не вызывается:
![[Pasted image 20240130030452.png]]![[Pasted image 20240130030500.png]]

Это связано с тем, что по завершению программы мы не закрываем наш контекст вызывая метод close(), т.е. по факту происходит утечка.
Т.к. интерфейс *ClassPathXmlApplicationContext* реализует интерфейс *AutoCloseable*, то мы можем просто воспользоваться try-с ресурсами (т.к. по завершению блока try, будет автоматически вызван метод close()):
![[Pasted image 20240130030814.png]]
![[Pasted image 20240130030822.png]]
Т.е. теперь destroy-метод вызывается.

Также теперь в beanFactory -> beanDefinitionMap -> beanDefinition, мы можем наблюдать destroy-method:
![[Pasted image 20240130031006.png]]
Замечание: В xml он может быть указан также только один.

Замечание: Модификатор доступа таких методов может быть любой, т.к. используется Reflection API.

---

### Пример destroy-method c помощью реализации интерфейса DisposableBean

Для этого достаточно реализовать интерфейс DisposableBean и реализовать метод destroy():
![[Pasted image 20240130031549.png]]

--- 

### Почему на prototype bean-ы не вызываются destroy-методы?

![[Pasted image 20240130032023.png]]
Из-за того, что на этапе *beans* singleton бины складываются в мапу *singletonObject*, то на них могут быть вызваны destroy-методы, т.к. они хранятся в контексте.

Но prototype бины не складываются в мапу *singletonObject*, поэтому они не хранятся в контексте, поэтому Spring на них никак не может вызывать эти методы, т.к. он их просто не видит.