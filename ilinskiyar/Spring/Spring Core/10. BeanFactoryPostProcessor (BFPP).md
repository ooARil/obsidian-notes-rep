Но как в [[9. Внедрение зависимостей с помощью property-файла]] с помощью SPeL, Spring заменил одно значение на другое, ведь это просто строка и это BeanDefinition?

Для этого возьмем бин PropertySourcesPlaceholderConfigurer, который мы добавляли в конфигурацию, чтобы у нас была возможность считать значения из .property-файла

И дойдя до его родителя PeropertyResourceConfigurer можно увидеть:
![[Pasted image 20240208051504.png]]
что данный класс реализует интерфейс BeanFactoryPostProcessor:
![[Pasted image 20240208051558.png]]
Замечание: Который является функциональным интерфейсом, содержащим метод, принимающий BeanFactory.

---

### Дебаг поведения интерфейса BeanFactoryPostProcessor

Если установить бп в PeropertyResourceConfigurer на переопределнном методе *postProcessorBeanFactory*, то мы увидим следующее
![[Pasted image 20240208052011.png]]:
1. Если посмотреть beanFactory -> beanDefinitionMap -> взять бин driver (т.к. он берет значение из .peroperty), то увидим что его значение все еще ${db.driver}:
		![[Pasted image 20240208052136.png]]
2. После чего в этот методе он распарсивает данную строку и сравнивает её с значениями из .property-файла:
		![[Pasted image 20240208053720.png]]
3. После чего просто заменяет значение:
			![[Pasted image 20240208053802.png]]
			![[Pasted image 20240208053814.png]]
			И мы получаем следующее значение:
			![[Pasted image 20240208053912.png]]

---

### В жизненный цикл бина добавляется новый этап - BeanFactoryPostProcessor

![[Pasted image 20240208053954.png]]
Пояснение: Т.е. перед тем как мы будем сортировать наши BeanDefinitions, после того как BeanDefinition попал в IoC контейнер, мы можем его пропустить через Bean Factory Post Processor:
- Чтобы данный этап выполнился, важно чтобы данный Bean Factory Post Processor были в виде бинов в нашей конфигурации.

Замечание: Именно на этом этапе наши бины, которые внедряют зависимость через .property-файл и приобретают себе нормальное значение. Т.е. на этом этапе мы можем подкрутить наш BeanDefinition (инструкцию по созданию бина)!!!

---

### Зачем он нужен?

**BeanFactoryPostProcessor:**

- Интерфейс `BeanFactoryPostProcessor` предоставляет метод `postProcessBeanFactory`, который вызывается после того, как все определения бинов (bean definitions) были считаны, но до того, как сами объекты бинов будут созданы и через конструктор (или фабричный метод) и эти бины будут доступны.
- Этот интерфейс дает вам возможность вмешаться в процесс конфигурации контейнера Spring и внести изменения, например, добавить или изменить свойства бинов (т.е. изменить сами BeanDefinition-ы, например PeropertyResourceConfigurer проверяет все бины), или даже добавить новые бины динамически.
- Вызывается для всех бинов (проходится по всем бинам) !!!

---

### Как Spring понимает, что это BeanFactoryPostProcessor ?

Как Spring понимает что это BeanFactoryPostProcessor, потому что судя по жизненному циклу их нужно каким-то образом создать в первую очередь и добавить в самое начало, перед тем, как вся эта метаинформация перейдет на следующие шаги?

Для этого Spring-у просто достаточно узнать, является ли бин записанный у нас в конфигурации объектом типа BeanFactoryPostProcessor:
![[Pasted image 20240208055112.png]]

Т.е. по факту Spring просто с помощью Reflection API определяет является ли тип BeanDefinition BeanFactoryPostProcessor-ом:
![[Pasted image 20240208055606.png]]
И если да, то такие такие объекты будут проинициализированы отдельно в первую очередь и их методы *postProcessorBeanFactory* будут вызваны.

Пояснение (почему в первую очередь?): Потому что эти бины нужны для инициализации других бинов!!! А данные бины (BeanFactoryPostProcessor) работают с их BeanDefinition.

---

### Самостоятельно создадим BeanFacotryPostProcessor

Создал свой BeanFactoryPostProcessor и добавил его в конфигурацию xml:
![[Pasted image 20240208061945.png]]
![[Pasted image 20240208062027.png]]
Пояснение: Данный бин не нужно никуда внедрять, поэтому id не указываю.


---

### Порядок вызова BeanFacotryPostProcessor

Запустив в дэбаге свой код, увидел, что сначала вызывался PeropertyResourceConfigurer и только потом мой LogBeanFactoryPostProcessor.
Это происходит из-за того, что у Spring также есть приоритет вызовов BeanFacotryPostProcessor.

Чтобы задать приоритет вызов существует два интерфейса:
- Ordered - интерфейс, который имеет всего лишь один метод, который возвращает значения от минимального до максимального значения int:
	- < 0 - самый низкий приоритет
	- > 0 - самый высокий приоритет
	![[Pasted image 20240208062308.png]]
- PriorityOrdered - но также существует еще один интерфейс, который делает то же самое, однако требуется, чтобы задать еще один уровень приоритетности (всегда будет вызываться перед Ordered)
	![[Pasted image 20240208062353.png]]

В попытке вызывать свой BFPP первее PeropertyResourceConfigurer, реализовал интерфейс Ordered:
![[Pasted image 20240208062630.png]]
Однако все равно мой BFPP вызывался после PeropertyResourceConfigurer, - это как раз связано с тем, что PropertyResourceConfigurer реализует интерфейс PriorityOrdered:
![[Pasted image 20240208062736.png]]
Пояснение: Хоть у него и выставлен самый низкий приоритет, но PriorityOrdered всегда вызывается перед Ordered.

В order у него указан самый низкий приоритет, то я реализовал интерфейс PriorityOrdered и выставил своему BFPP самый высокий приоритет, - и в этом случае мой BFFP вызывался раньше, чем PeropertyResourceConfigurer:
![[Pasted image 20240208062945.png]]

Таким образом, можно повлиять на порядок вызова BFFP в Spring!!! Потому что BFFP, которые мы создаем или которые подключаем, находятся в одной коллекции (т.к. относятся к одному типу).