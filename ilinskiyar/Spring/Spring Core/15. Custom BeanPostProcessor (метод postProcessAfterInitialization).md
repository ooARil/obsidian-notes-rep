Если мы попытаемся создать прокси в методе postProcessBeforeInitialization (например: мы хотим, чтобы перед каждым методом класса писалось сообщение "Open transaction", а по окончанию метода писалось "Close" ):
![[Pasted image 20240219011638.png]]
![[Pasted image 20240219011625.png]]
Пояснение:
1. Получаем тип бина.
2. Проверяем есть ли над ним аннотация с таргетом type.
3. Если да, то создаем прокси объект, в который передаем класс-загрузчик, список интерфейсов, и вместо invitationHandler передаем лямбду-функцию (т.к. это функциональный интерфейс).

Вот так выглядит прокси-объект:
![[Pasted image 20240219015140.png]]

То мы сталкиваемся со следующей проблемой, из-за того, что у нас в postProcessBeforeInitialization() создается прокси, у нас пропускается вызов init-метода:
![[Pasted image 20240219012436.png]]
![[Pasted image 20240219012323.png]]Пояснение: Потому что это бин уже прокси, и это уже совершенно другой класс (с другими методами) -> Таким образом мы нарушаем жизненный цикл бинов.
Замечание: Кроме того, если бы bpp, который отвечает за инжект зависиомстей (например InjectBeanPostProcessor [[14. Custom BeanPostProcessor (метод postProcessBeforeInitialization)]]) шел бы после нашего bpp
![[Pasted image 20240219013342.png]]
, то он бы не увидел никаких полей с аннотацией @InjectBean, т.к. это прокси объект, с другими полями (аналогично с теми bpp, который идут после нашего bpp, - если в них идет проверка с помощью рефлексии на присутствие аннотаций)

Все манипуляции с бинами: создание прокси, подмены на другие бины и т.д. - нужно делать ТОЛЬКО в postProcessAfterInitialization():
![[Pasted image 20240219013050.png]]

Однако стоит быть внимательным, т.к. теперь в других bpp в postProcessAfterInitialization() может также быть создан прокси объект поэтому необходимо изменить код:
![[Pasted image 20240219014053.png]]
Пояснение: 
1. Т.к. в beforeIntialization() принято в негласное правило, что прокси объект создавать нельзя, то можно создать мапу, которая будет содержать класс бина, над типом которого стоит аннотация @Transaction.
2. После чего из мапы просто достаем бин по имени, и оставшаяся логика анлогичная.
Замечание: В метод invoke все равно необходимо передать прокси объект (т.е. bean),
![[Pasted image 20240219014358.png]]
т.к. благодаря этому можно будет прокси оборачивать в прокси, что дает очень мощный функционал:

Теперь init-метод вызывается:
Т.к. теперь мы возвращаем не прокси, а настоящий бин
![[Pasted image 20240219014523.png]]
![[Pasted image 20240219014559.png]]

Но т.к. мы возвращаем прокси, то на этапе destroy-метод, данный метод не вызывается:
![[Pasted image 20240219014727.png]]

---

### Оборачивание прокси в прокси объект

Чтобы продемонстрировать такую возможность, создам еще одну аннотацию @Auditing, которая делает все то же самое:
![[Pasted image 20240219015952.png]]
![[Pasted image 20240219015920.png]]
И можем увидеть результат:
![[Pasted image 20240219020023.png]]

А также что у нас теперь прокси объект, вложен в прокси объект:
![[Pasted image 20240219020035.png]]