EventListenerMethodPostProcessor - это BeanFactoryPostProcessor [[11. Annotated based config]], который предоставляет работу с аннотацией @EventListener, и нужен для того, чтобы реализовывать паттерн Observer (наблюдатель).

---

### Идея паттерна наблюдатель

Listener состоит из:
- Event:
	![[Pasted image 20240419010137.png]]
	Событие - представляет из себя просто набор полей, которые нам нужны.

- Listener:
	![[Pasted image 20240419010356.png]]
	Listener - это классы, с одним единственным методом, который в параметрах содержит наш объект Event.

И мы можем подписываться/отписываться на определенные события Event, которые будут обрабатывать Listener-ы:
![[Pasted image 20240419010629.png]]
Пояснение: Подписаться/отписаться - это просто добавление/удаление Listener-классов из коллекции.

---

### Настройка @EventListener

- Event:
	![[Pasted image 20240419010923.png]]
	Пояснение: Для того, чтобы подключить Event-класс в систему EventListener spring-а, то все наши Event-классы должны просто наследоваться от EventObject:
		EventObject - класс, который содержит в себе единственное поле source
		![[Pasted image 20240419011111.png]]
		source - это главный объект нашего Event-класса (т.е. объект на котором произошло событие).
	
	Замечание: Также еще лучше наследоваться от Spring-класса ApplicatioEvent, который уже наследуется от EventObject.

- Listener:
	![[Pasted image 20240419011609.png]]
	Listener-класс должен быть обязательно @Component, чтобы его считал BeanFactoryPostProcessor.

	Метод помеченный аннотацией @EventListner должен содержать только один метод, который должен содержать параметр типа EventObject.

	И в данном методе мы можем писать абсолютно любую логику (например в слушателе этого события будет происходить его логирование).

	Пояснение: Неявно на основании каждой аннотации @EventListener будет создан объект типа ApplicationListener:
	![[Pasted image 20240419012334.png]]

	И если придет событие EntityEvent, то все @EventListener, которые содержат в параметре метода EntityEvent будут вызваны.

- Подписаться на Listner:
	![[Pasted image 20240420154500.png]]
	Т.е. после того как будет вызван метод findById, мы хотим вызывать Listener-ы на EntityEvent, на которые мы неявно подписались (т.е. будут вызваны все @EventListener, чьи методы принимают EntityEvent).

	ApplicationEventPublisher - это интерфейс, который позволяет публиковать события в приложении, которые потом будут прослушивать Listener-классы.

	Результат:
	При запуске у нас срабатывает листенер:
	![[Pasted image 20240420155353.png]]

----

### Возможности Listener-ов

- Если у нас несколько Listener-ов слушают одно и тоже событие, то мы можем задать им порядок, т.к. они представляют собой просто коллекцию:
	![[Pasted image 20240420155702.png]]
	Поэтому можно просто задать приоритет через @Order:
	![[Pasted image 20240420155852.png]]
	Результат:
	![[Pasted image 20240420155902.png]]

- Для события можно задать конкретное условие, чтобы оно было прослушано:
	![[Pasted image 20240420160049.png]]
	Пояснение: В condition можно использовать SpEl, т.е. например если мы укажем:
	- `#root.event ...` - мы обратимся к объекту AppicationEvent (в котором лежит наш source)
	- `#root.args ...`  - мы обратимся к аргументам нашего метода помеченного @EventListener.
		Пояснение: т.е. чтобы получить из аргументов метода наш EntityEvent, то нужно написать `#root.args[0]` (или более короткая запись `#a0` или `#p0`)

	![[Pasted image 20240420161125.png]]
	Пояснение: Т.е. 
	1. через `#root.args[0]` идет обращение к нашему entityEvent (т.к. он первый в списке аргументов метода)
	2. потом мы обращаемся к полю accessType нашего объекта entityEvent
	3. после чего нашего условие заключается в том, что данный @EventListener для данного события должен вызываться только тогда, когда его accessType = READ

	Результат: Т.к. в publisher-е мы передаем событие с accessType = READ, наш слушатель сработал:
	![[Pasted image 20240420161210.png]]
	Но если мы заменим условия на DELETE:
	![[Pasted image 20240420161238.png]]
	То данный слушатель уже не сработает (в логе нет записи в консоль)