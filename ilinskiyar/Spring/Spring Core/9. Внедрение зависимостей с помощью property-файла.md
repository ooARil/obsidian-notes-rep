
Чтобы была возможность вносить изменения только в конфигурацию проекта, а не менять постоянно хардкод переменные их можно вынести в специальные файлы конфигурации: .properties, .yaml:
![[Pasted image 20240208042710.png]]

Spring также работает с этими текстовыми файлами конфигурациями.

---

### Добавление .property-файла в файл-конфигурацию XML

Создаем файл application.properties в resources:
![[Pasted image 20240208042851.png]]

Для того, чтобы Spring смог его считать, необходимо создать бин PropertySourcesPlaceholderConfigurer, который отвечает за считывание .property файла:
![[Pasted image 20240208043344.png]]
Пояснение: Т.к. данный бин мы нигде не инжектим, а просто добавляем в контекст, то можем не указывать ему id.
Замечание: 
- В данном случае мы должны указать не $<constructor-arg>$ , потому что мы не инжектим завимость в данный бин, а должны использовать элемент $<property>$, в котором указываем путь до .property файла.
- Если у нас только один .property файл, то достаточно указать в элементе name значение "location"
- Если у нас несколько .property файлов, то можем указать "locations" и перечислить их через запятую:
	![[Pasted image 20240208043520.png]]

Но из-за того бин PropertySourcesPlaceholderConfigurer практически всегда требуется, чтобы его не прописывать в конфигурации каждый раз, то теперь данный бин вынесли в отдельную xsd-схему, которую можно заимпортировать (указать в нашей xml шапку с namespace-ом данной xsd схемы):
![[Pasted image 20240208050825.png]]
Пояснение: Т.е. мы обращаемся к другой заимпортированной xsd схеме, и берем элемент $<context>$, в который просто указываем путь до нашего .property файла.

---

### Пример внедрения зависимостей значений из .property-файла с помощью Java Expression Language (JEL)

Используя JEL мы можем считать из .property-файла значение. Для этого нужно следовать следующей конвенцией:
```xml
${значение из .property-файла}
```
![[Pasted image 20240208044449.png]]
![[Pasted image 20240208044502.png]]
Пояснение: Можно увидеть что Intelji Idea подсказывает какие значения мы можем вытащить из .property-файла.

Кроме того, хоть у нас в .property-файла все значения - это строки, то если мы попытаемся String записать в переменную, которая является Integer:
![[Pasted image 20240208044849.png]]
То у нас сработает автоматическое приведение типов.
Пояснение: Но работает не на все, например в LocalDate так не получится с конвентировать, для этого понадобиться сделать дополнительную обработку, которую предлагает SpEL.

---

### Spring Expression Language (SpEL)

SpEL - надстройка над Java Expression Language, который предлагает еще больше возможностей.
Для того, чтобы использовать SpEL нужно:
```xml
#{(значение из .property-файла).(вызов метода)}
```

Помимо обращения к .property-файлу, SpEL может работать даже с бинами!
![[Pasted image 20240208045400.png]]
Пояснение: Intelji Idea подсвечивает, что можно в выражении использовать бин.

К примеру указав в SpEL бин драйвер Intelji Idea подсвечивает какие методы мы можем у него вызывать:
![[Pasted image 20240208045519.png]]
![[Pasted image 20240208045600.png]]
Пояснение: driver - бин с типом String.

Кроме того, можно вызывать даже разные классы. Например в SpEL указал утилитный класс Math. Но важно, чтобы можно указать тип, то нужно соблюдать следующую конвенцию:
```xml
#{T(Тип).(метод)}
```
Т.е. важно указать $T$:
![[Pasted image 20240208045849.png]]

Также можно получить из .property-файла значение, и над этим значением провести какие-то действия:
![[Pasted image 20240208050101.png]]
Пояснение: Но чтобы обратиться к .property-файлу, нужно указать одинарные кавычки, т.к. мы возвращаем строку!

---

### Результат внедрения зависимостей через .property-файл

Можно увидеть, что все зависимости были успешно внедрены:
![[Pasted image 20240208050939.png]]