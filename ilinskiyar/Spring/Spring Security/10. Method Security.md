---

---

Чтобы аннотации [[#@PreAuthorize и @PostAuthorize]] , [[#@Secured]], [[#@PreFilter и @PostFilter]] сработали необходимо в нашем конфигурационном классе поставить аннотацию `@EnableMethodSecurity`:
![[Pasted image 20240516001142.png]]
Замечание: 
- Есть также `@EnableGlobalMethodSecurity`, но её не следует использовать.
- Также для реактивного программирования есть аннотация `@EnableReactiveMethodSecurity`.

![[Pasted image 20240516001507.png]]
Пояснение:
- `prePostEnabled` (включено по умолчанию) - позволяет нам использовать аннотации [[#@PreAuthorize и @PostAuthorize]], [[#@PreFilter и @PostFilter]]
- `securedEnabled` (выключено по умолчанию) - позволяет нам использовать аннотации [[#@Secured]]
 
---
### @PreAuthorize и @PostAuthorize

- `@PreAuthroize` - используется для проверки прав доступа до вызова метода/объекта, над которым она стоит:
	![[Pasted image 20240508161916.png]]
	Пояснение:
	- Данную аннотацию можно ставить как над методом, так и над классом.
	- Права доступа проверяются с помощью SpEL. 

	Поэтому используя SpEL и [[#SecurityExpressionRoot]] мы можем описать, какая роль должна быть у пользователя, чтобы использовать метод:
	![[Pasted image 20240508162925.png]]
	Роль пользователя, которая у него должна быть для доступа к этому методу, происходит в `PreAuthorizeAuthorizationManager`:
	![[Pasted image 20240508171321.png]]
	Пояснение: [[#Как происходит проверка прав пользователя на основании аннотаций?]]

	Также из-за того что мы используем SpEL мы можем прописывать сразу несколько условий:
	![[Pasted image 20240516000838.png]]
	
- `@PostAuthorize` - используется для выполнения какой-либо логики после выполнения метода, к которому она применяется:
	![[Pasted image 20240508182514.png]]
	Пояснение: Т.е. данная аннотация нужна для проверки, что у пользователя есть доступ к данному значению. Если пользователь не имеет прав доступа к возвращаемому значению, метод не будет выполнен и будет выдано исключение `AccessDeniedException`.

	Пояснение:
	- `returnObject` - это наше возвращаемое значение метода, над которым мы можем выполнять операции.

	Замечание: Работает по аналогии с [[#Как происходит проверка прав пользователя на основании аннотаций?]].

---
### @Secured

Аналогично как с [[#@PreAuthorize и @PostAuthorize]], но в ней необходимо вручную прописывать префикс `ROLE_`:
![[Pasted image 20240516002100.png]]
поэтому не рекомендуется её использовать.

---
### @PreFilter и @PostFilter

Аннотации `@PreFilter` и `@PostFilter` нужны, чтобы фильтровать входные или выходные значения методов (т.е. по аналогии с `@PostAuthorize` но для коллекций):
![[Pasted image 20240516002752.png]]
Пояснение:
- `filterObject` - это наша возвращаемая коллекция метода, над которой мы можем выполнять операции.
- `filterObject.role.name().equals('ADMIN')` - т.е. данная условие будет проверяться для каждого объекта в коллекции. Если условие фильтрации не будет выполнено, то значение будет убрано из коллекции.

Замечание:
- Т.к. мы используем SpEL мы можем делать более сложные условия:
	![[Pasted image 20240516003128.png]]
	т.е. мы можем обращаться к бинам.

- Чаще все используется именно `@PostFilter` нежели `@PreFilter`.

---

### SecurityExpressionRoot

SecurityExpressionRoot - специальный вспомогательный класс, в котором определены публичные методы, которые мы можем использовать в SpEL выражениях, таких аннотациях как [[#@PreAuthorize и @PostAuthorize]] и т.д.:
![[Pasted image 20240508162706.png]]
![[Pasted image 20240508162745.png]]

---
### Как происходит проверка прав пользователя на основании аннотаций?

Когда например ставиться аннотация `@PreAuthorize` в `UserService`:
![[Pasted image 20240508164256.png]]
то у нас создает CGLIB-прокси, а именно `AuthorizationManagerBeforeMethodInterceptor`:
![[Pasted image 20240508165934.png]]
	Пояснение: `AuthorizationManagerBeforeMethodInterceptor` создается он как бин (это тема AOP):
		![[Pasted image 20240508170023.png]]

и как можно увидеть, то будет вызываться `PreAuthorizeAuthorizationManager`:
![[Pasted image 20240508170309.png]]

И получается, что когда у нас срабатывает метод, помеченный аннотацией `@PreAuthrorize` происходит следующее:
1. Вызывается наш прокси-класс, в методе которого стояла данная аннотация:
	![[Pasted image 20240508170644.png]]

2. После чего в `AuthorizationManagerBeforeMethodInterceptor` срабатывает метод `invoke`:
	![[Pasted image 20240508170738.png]]
	![[Pasted image 20240508170849.png]]

	который вызывает метод `attemptAuthorization`, в котором вызывается `PreAuthorizeAuthorizationManager`, который был задан в бине.
	![[Pasted image 20240508171128.png]]
	![[Pasted image 20240508171329.png]]