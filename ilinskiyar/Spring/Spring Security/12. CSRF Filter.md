Ранее мы отключали в SecuirtyFilterChain конфигурации CSRF фильтр:
![[Pasted image 20240519144141.png]]
![[Pasted image 20240519144258.png]]

---

### Для чего нужен CSRF Filter?

CSRF Filter в Spring Security - это фильтр, предназначенный для защиты от атак межсайтовой подделки запросов (CSRF, Cross-Site Request Forgery):
![[Pasted image 20240519144324.png]]
Пояснение:
1. Представим что у нас есть сайт bank.dmdev.com:
	![[Pasted image 20240519150310.png]]

3. Представим, что у нас есть login-форма, по которой мы проводим аутентификацию пользователя:
	![[Pasted image 20240519144758.png]]
	Как только мы только прошли аутентификацию мы получили 200-ый статус и JSESSIONID (наш id сессии - т.е. куку):
	![[Pasted image 20240519144836.png]]

3. Также у нас есть форма для перевода денег в банк:
	![[Pasted image 20240519144916.png]]
	И если мы захотим сделать перевод денег, то JSESSION (id сессии) прикрепляется к нашему запросу (и из-за того что мы прошли аутентификацию (т.е. у нас есть id сессии) мы спокойно делаем перевод денег):
	![[Pasted image 20240519145159.png]]

4. Теперь допустим мы зашли на другой сайт, и мы видим форму с кнопкой "ВЫЙГРАЙ ДЕНЬГИ":
	![[Pasted image 20240519145300.png]]
	Пояснение: И в это форме указывается "сколько денег перевести = 1000", "аккаунт злоумышленника = evilsAccount" и мой аккаунт. Но т.к. эти атрибуты скрыты (hiden), пользователь видит только кнопку "ВЫЙГРАЙ ДЕНЬГИ".

	И данный сайт в скрытую по этой кнопке ходит на наш сайт, на котором мы предоставляем отправку денег в банк.

	И т.к. куки (JSSESSION) прикрепляются к хосту (т.е. к bank.dmved.com), то на нашем сайте все равно откуда пришел данный запрос (мы не проверяем это), браузер автоматически прикрепит все куки (потому что мы уже мы прошли аутентификацию на нашем сайте bank.dmdev.com):
	![[Pasted image 20240519145732.png]]
	Пояснение: Т.е. подставился наш куки по тому же самому запросу, и мы перевили деньги злоумышленнику, - потому что на нашем сайте bank.dmdev.com мы не проверяем откуда пришел запрос (и мы не можем различить, где запрос пришел от хорошего сайта, а где от плохого).

Замечание: Данный кейс происходит только тогда, когда мы используем куки для идентификации нашего пользователя. Поэтому если мы куки не используем, то CSRF нам не нужен.

---

### Как защитить свой сайт с помощью CSRF Filter?

У нас есть два способа:
![[Pasted image 20240519150750.png]]
- `Syncronizer Token Pattern` (данный способ используется в Spring Secuirty) - это наиболее распространенный подход. Сервер генерирует случайный токен CSRF и сохраняет его в сессии пользователя. Этот токен должен быть включен в каждый защищенный запрос (обычно в качестве скрытого поля формы или заголовка запроса):

	Т.е. мы в наш запрос прикрепляем дополнительный параметр `_csrf`
	![[Pasted image 20240519154931.png]]
	т.е. это какой-то специальный сгенерированный токен, который храниться у нас на сервере и прикрепляется к нашему пользователю.
	
	Пояснение: 
	- Его можно хранить в базе данных, но по умолчанию он как храниться как обычный атрибут в объекте сессии. И данный токен присваивается один раз, когда пользователь проходит аутентификацию.
	
	- И если мы попытаемся сделать точно такой же запрос с сайта злоумышленника, то т.к. злоумышленник не знает этот crsf-токен (а знает только наш JSESSION)
	 ![[Pasted image 20240519155403.png]]
	 то при отправке запроса он будет получать 403 ошибку:
	 ![[Pasted image 20240519155430.png]]
	 потому что теперь сервер может различить запрос от хорошего сайта и запрос от злоумышленника (и мы не переведем деньги).

- `SameSite Attribute` - подход основан на использовании атрибута SameSite для HTTP-cookie. Атрибут SameSite может иметь значения `Strict`, `Lax` или `None`:


--- 

### Когда использовать CSRF Filter?

Используется только тогда, когда мы используем браузер для отправки с наших форм.

Пояснение: Т.е. это не браузер клиенты, т.е. например мобильное устройство или мы не используем JSESSION (т.е. куки), то в этом случае CSRF не нужно подключать.

---

### Как подключить CSRF Filter с Syncronizer Token Pattern по умолчанию

В `HttpSecuirty`- билдере по умолчанию включен CSRF Filter, поэтому нам достаточно убрать `csrf().disable()`:
![[Pasted image 20240519155941.png]]Пояснение: И теперь у нас будет подключен CSRF Filter с crsf-токеном по умолчанию.


---

### Как устроен CSRF Filter?

![[Pasted image 20240519160127.png]]
Пояснение:
- По умолчанию в качестве `CsrfTokenRepository` мы используем `HttpSessionCsrfTokenRepository` - т.е. сохраняется в качестве атрибута сессии:
	![[Pasted image 20240519160543.png]]
	и вот как раз мы можем увидеть, что он либо может передаваться в параметрах формы (т.е. `_csrf`), либо в хэдерах самого запроса (т.е. `X-CSRF-TOKEN`)

- И т.е. когда приходит запрос у нас срабатывает фильтр и происходит следующее:
	1. Пытаемся получить из запрос объект сессии, из которого пытаемся достать csrf-токен:
		![[Pasted image 20240519161435.png]]
		![[Pasted image 20240519160803.png]]
		по дефолтному имени атрибута:
		![[Pasted image 20240519161406.png]]

	2. Если csrf-токен отсутствует в объекте сессии, то происходит следующее:
		![[Pasted image 20240519161544.png]]
		1. Генерируем новый токен:
			![[Pasted image 20240519161607.png]]
			![[Pasted image 20240519161622.png]]

			![[Pasted image 20240519161633.png]]
			Пояснение: Т.е. данный csrf-токен содержит следующую информацию:
			- В каком хэдере должен лежать:
				по умолчанию:
				![[Pasted image 20240519161836.png]]

			- В каком параметре формы должен лежать:
				по умолчанию:
				![[Pasted image 20240519161900.png]]

			- И сам tocken:
				по умолчанию просто UUID:
				![[Pasted image 20240519161707.png]]

		2. Сохраняем в объект сессии:
			![[Pasted image 20240519162016.png]]
			![[Pasted image 20240519162029.png]]
			Пояснение:
			- Т.е. если пришел null токен (в нашем случае невозможно) удаляется атрибут c crsf-токеном из объект сессии.
			- Если не null, то кладем сгенерированный токен в объект сессии в качестве атрибута с наименованием по умолчанию:
				![[Pasted image 20240519161406.png]]

	3. Crsf-токен вставляется в качестве атрибута запроса (чтобы его можно было использовать в дальнейшем):
		![[Pasted image 20240519162900.png]]

	4. Если запросу не требуется проверка crsf-токена, то идет переход к следующему фильтру SecuirtyFilterChain:
		![[Pasted image 20240519162938.png]]

	5. Далее извлекаем из входящего запроса их хэдеров или параметров пришедший csrf-токен:
		![[Pasted image 20240519163050.png]]
		Пояснение: 
		1. Т.е. сначала проверяем есть ли в хэдере у нас атрибут с названием нашего crsf-токена, который мы получили 