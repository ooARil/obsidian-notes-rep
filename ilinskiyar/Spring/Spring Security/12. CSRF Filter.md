Ранее мы отключали в SecuirtyFilterChain конфигурации CSRF фильтр:
![[Pasted image 20240519144141.png]]
![[Pasted image 20240519144258.png]]

---

### Для чего нужен CSRF Filter?

CSRF Filter в Spring Security - это фильтр, предназначенный для защиты от атак межсайтовой подделки запросов (CSRF, Cross-Site Request Forgery):
![[Pasted image 20240519144324.png]]
Пояснение:
1. Представим что у нас есть сайт bank.dmdev.com:
	![[Pasted image 20240519150310.png]]

3. Представим, что у нас есть login-форма, по которой мы проводим аутентификацию пользователя:
	![[Pasted image 20240519144758.png]]
	Как только мы только прошли аутентификацию мы получили 200-ый статус и JSESSIONID (наш id сессии - т.е. куку):
	![[Pasted image 20240519144836.png]]

3. Также у нас есть форма для перевода денег в банк:
	![[Pasted image 20240519144916.png]]
	И если мы захотим сделать перевод денег, то JSESSION (id сессии) прикрепляется к нашему запросу (и из-за того что мы прошли аутентификацию (т.е. у нас есть id сессии) мы спокойно делаем перевод денег):
	![[Pasted image 20240519145159.png]]

4. Теперь допустим мы зашли на другой сайт, и мы видим форму с кнопкой "ВЫЙГРАЙ ДЕНЬГИ":
	![[Pasted image 20240519145300.png]]
	Пояснение: И в это форме указывается "сколько денег перевести = 1000", "аккаунт злоумышленника = evilsAccount" и мой аккаунт. Но т.к. эти атрибуты скрыты (hiden), пользователь видит только кнопку "ВЫЙГРАЙ ДЕНЬГИ".

	И данный сайт в скрытую по этой кнопке ходит на наш сайт, на котором мы предоставляем отправку денег в банк.

	И т.к. куки (JSSESSION) прикрепляются к хосту (т.е. к bank.dmved.com), то на нашем сайте все равно откуда пришел данный запрос (мы не проверяем это), браузер автоматически прикрепит все куки (потому что мы уже мы прошли аутентификацию на нашем сайте bank.dmdev.com):
	![[Pasted image 20240519145732.png]]
	Пояснение: Т.е. подставился наш куки по тому же самому запросу, и мы перевили деньги злоумышленнику, - потому что на нашем сайте bank.dmdev.com мы не проверяем откуда пришел запрос (и мы не можем различить, где запрос пришел от хорошего сайта, а где от плохого).

Замечание: Данный кейс происходит только тогда, когда мы используем куки для идентификации нашего пользователя. Поэтому если мы куки не используем, то CSRF нам не нужен.

---

### Как защитить свой сайт с помощью CSRF Filter?

У нас есть два способа:
![[Pasted image 20240519150750.png]]
- `Syncronizer Token Pattern` (данный способ используется в Spring Secuirty) - это наиболее распространенный подход. Сервер генерирует случайный токен CSRF и сохраняет его в сессии пользователя. Этот токен должен быть включен в каждый защищенный запрос (обычно в качестве скрытого поля формы или заголовка запроса):

	Т.е. мы в наш запрос прикрепляем дополнительный параметр `_csrf`
	![[Pasted image 20240519154931.png]]
	т.е. это какой-то специальный сгенерированный токен, который храниться у нас на сервере и прикрепляется к нашему пользователю.
	
	Пояснение: 
	- Его можно хранить в базе данных, но по умолчанию он как храниться как обычный атрибут в объекте сессии. И данный токен присваивается один раз, когда пользователь проходит аутентификацию.
	
	- И если мы попытаемся сделать точно такой же запрос с сайта злоумышленника, то т.к. злоумышленник не знает этот crsf-токен (а знает только наш JSESSION)
	 ![[Pasted image 20240519155403.png]]
	 то при отправке запроса он будет получать 403 ошибку:
	 ![[Pasted image 20240519155430.png]]
	 потому что теперь сервер может различить запрос от хорошего сайта и запрос от злоумышленника (и мы не переведем деньги).

- `SameSite Attribute` - подход основан на использовании атрибута SameSite для HTTP-cookie. Атрибут SameSite может иметь значения `Strict`, `Lax` или `None`:


--- 

### Когда использовать CSRF Filter?

Используется только тогда, когда мы используем браузер для отправки с наших форм.

Пояснение: Т.е. это не браузер клиенты, т.е. например мобильное устройство или мы не используем JSESSION (т.е. куки), то в этом случае CSRF не нужно подключать.

---

### Как подключить CSRF Filter с Syncronizer Token Pattern по умолчанию

В `HttpSecuirty`- билдере по умолчанию включен CSRF Filter, поэтому нам достаточно убрать `csrf().disable()`:
![[Pasted image 20240519155941.png]]Пояснение: И теперь у нас будет подключен CSRF Filter с crsf-токеном по умолчанию.


---

### Как устроен CSRF Filter?

![[Pasted image 20240519160127.png]]
Пояснение:

Прикол почему в фильтре работает именно LazyCsrfTokenRepository - т.е. он делегирует на получение токена из `HttpSessionCsrfTokenRepository`, а вот сам токен не сохраняет в сессию, это почему-то делает на первом этапе сам запрос когда дергается CsrfRequestDataValueProcessor (ну в остальном плане все понятно вроде)

- По умолчанию в качестве `CsrfTokenRepository` мы используем `LazyCsrfTokenRepository`:
	![[Pasted image 20240519214851.png]]
	Пояснение: 
	- Данный сервис создает CSRF-токены только тогда, когда они действительно необходимы [[#В чем смысл LazyCsrfTokenRepository?]]. 
	- Он делегирует всю работу другому сервису `HttpSessionCsrfTokenRepository`, который сохраняет csrf-токен в качестве атрибута сессии: 
		![[Pasted image 20240519160543.png]]
		Замечание: Вот как раз мы можем увидеть, что он либо может передаваться в параметрах формы (т.е. `_csrf`), либо в хэдерах самого запроса (т.е. `X-CSRF-TOKEN`)

- И т.е. когда приходит запрос у нас срабатывает фильтр и происходит следующее:
	1. Пытаемся получить из запрос объект сессии, из которого пытаемся достать csrf-токен:
		![[Pasted image 20240519161435.png]]
		![[Pasted image 20240519215414.png]]
		![[Pasted image 20240519160803.png]]
		по дефолтному имени атрибута:
		![[Pasted image 20240519161406.png]]

	2. Если csrf-токен отсутствует в объекте сессии, то происходит следующее:
		![[Pasted image 20240519161544.png]]
		1. Генерируем новый токен:
			![[Pasted image 20240519161607.png]]
			![[Pasted image 20240519215934.png]]
			![[Pasted image 20240519161622.png]]
			![[Pasted image 20240519161633.png]]
			Пояснение: Т.е. данный csrf-токен содержит следующую информацию:
			- В каком хэдере должен лежать:
				по умолчанию:
				![[Pasted image 20240519161836.png]]

			- В каком параметре формы должен лежать:
				по умолчанию:
				![[Pasted image 20240519161900.png]]

			- И сам tocken:
				по умолчанию просто UUID:
				![[Pasted image 20240519161707.png]]

			После чего полученный токен оборачивается в `SaveOnAccessCsrfToken`:
			![[Pasted image 20240519220105.png]]
			![[Pasted image 20240519220219.png]]

		2. Сохраняем в объект сессии:
			![[Pasted image 20240519162016.png]]
			![[Pasted image 20240519220239.png]]
			Пояснение: А вот тут уже интересно, он не сохраняет в сессию сразу же, - в этом как раз суть оптимизации ленивого репозитория [[#В чем смысл LazyCsrfTokenRepository?]]
			- Но если пришел null токен (в нашем случае невозможно) удаляется атрибут c crsf-токеном из объект сессии:
				![[Pasted image 20240519220526.png]]

	3. Crsf-токен вставляется в качестве атрибута запроса (чтобы его можно было использовать в дальнейшем):
		![[Pasted image 20240519162900.png]]
		Пояснение: Данная операция необходима, потому что на этапе 2 в дефолтной реализации мы не записываем в атрибуты сессии csrf-токен. Мы записываем его в сам запрос, чтобы записать только тогда, когда он нам потребуется.

	4. Если запросу не требуется проверка crsf-токена, то идет переход к следующему фильтру SecuirtyFilterChain:
		![[Pasted image 20240519162938.png]]
		![[Pasted image 20240519220847.png]]
		Пояснение: Т.е. CRSF-фильтр и crsf-токен по умолчанию нужен для проверки только тех запросов, которые изменяют структуру данных (т.е. POST, PUT, PATCH, DELETE и т.д.), иначе проверка пропускается.

	5. Далее извлекаем из входящего запроса их хэдеров или параметров пришедший csrf-токен:
		![[Pasted image 20240519163050.png]]
		Пояснение: Т.е. достаем из хэдеров или параметров csrf-токен:
		![[Pasted image 20240519221803.png]]

	6. Сравниваем пришедший с фронта csrf-токен (`actual`) и наш полученный на 1ом этапе из сессии csrf-токен:
		![[Pasted image 20240519221926.png]]
		В случае если токены не совпадают, упадет 403 ошибка.

		Замечание: 
		- Однако возникает вопрос, а как мы вообще можем сравнивать, csrf-токены, если на этапе 5 их может не быть, т.к. они генерируется на 2ом этапе.
		
		Вопрос: 
		- И у нас должен быть обязательно сначала выполнен запрос, который не меняет данные, чтобы был выполнен шаг 4 (просто иначе на POST запросе упадет ошибка, т.к. не будет crsf-токена).

		 И тогда возникает вопрос, а как это вообще будет работать, если POST запрос мы в принципе выполнить не сможем, а если мы GET запрос выполним, то у нас сгенериться crsf-токен, но не запишется в атрибуты сессии (шаг 2.2)?

		 А вот окажется запишется, из-за обертки `SaveOnAccessCsrfToken`, которая была сделана на 2ом шагу.

		Ответ:
		1. [[#Как передать в запросах формы csrf-токен?]]
		2. [[#Как при первом вызове запроса не изменяющего состояние (т.е. "GET", "HEAD", "TRACE", "OPTIONS") crsf-токен записывается в атрибуты сессии и не ломает логику]]

---

### В чем смысл LazyCsrfTokenRepository?




---

### Как передать в запросах формы csrf-токен?

Начнем с того, чтобы добавить csrf-токен на нашу форму необходимо сделать следующее. Есть два варианта реализации:
1. Вручную:
	![[Pasted image 20240520020714.png]]
	![[Pasted image 20240520144320.png]]
	Пояснение: В этом случае не будет использоваться `CsrfRequestDataValueProcessor`.

	И при запуске у нас заполниться crsf-токен:
	![[Pasted image 20240520150857.png]]
	Пояснение: [[#Как при первом вызове запроса не изменяющего состояние (т.е. "GET", "HEAD", "TRACE", "OPTIONS") crsf-токен записывается в атрибуты сессии и не ломает логику]]

2. Вместо ручной реализации можно использовать специальный класс `CsrfRequestDataValueProcessor`, который автоматически добавляет во все thymeleaf-формы с методом POST (и т.д.):
	![[Pasted image 20240520143409.png]]
	![[Pasted image 20240520144330.png]]

	Cуть данного сервиса в том, что когда у нас выполняет GET-запрос и мы получаем форму:
	![[Pasted image 20240520143550.png]]
	![[Pasted image 20240520143629.png]]
	то данный сервис будет проходиться по всем `th:action` (т.е. запросам), у который в значении указан `@{сам запрос}` и в с эти запросы он будет подставлять скрытое поле с параметром в который будет вставлен crsf-токен:
	![[Pasted image 20240520143858.png]]

	Пояснение: И это очень удобно тем, что нам не нужно вручную добавлять данный параметр, достаточно просто следовать этой записи:
	![[Pasted image 20240520143940.png]]

	Замечание: Однако важно помнить, что это касается ТОЛЬКО тех запросов, который меняют состояние (т.е. POST, DELETE и т.д., [[#Как устроен CSRF Filter?]] пункт 4)

	И при запуске у нас заполниться crsf-токен:
	![[Pasted image 20240520150857.png]]
	Пояснение: [[#Как при первом вызове запроса не изменяющего состояние (т.е. "GET", "HEAD", "TRACE", "OPTIONS") crsf-токен записывается в атрибуты сессии и не ломает логику]]

---

### Как при первом вызове запроса не изменяющего состояние (т.е. "GET", "HEAD", "TRACE", "OPTIONS") crsf-токен записывается в атрибуты сессии и не ломает логику

У нас получается так, что первым запросом на форме срабатывает именно GET-запрос, который возвращает как раз саму форму:
![[Pasted image 20240520143550.png]]

И у нас на основании [[#Как устроен CSRF Filter?]] получается следующее при первом запросе:
1. Мы создали обертку crsf-токена:
	![[Pasted image 20240519220105.png]]
	
2. Записали его в атрибуты запроса:
	![[Pasted image 20240519162900.png]]

3. После чего перешли к следующему фильтру, т.к. тип нашего запроса - GET:
	![[Pasted image 20240519162938.png]]
	![[Pasted image 20240519220847.png]]

После чего происходит следующее:
- В случае если на форме мы вручную указываем параметр:
	![[Pasted image 20240520020714.png]]
	то у нас срабатывает логика, которая на основании тэгов, видит что у нас есть hidden-тип, в котором мы вызываем следующие методы:
	![[Pasted image 20240520145209.png]]

	1. `_csrf.getParameterName()`:
		![[Pasted image 20240520145308.png]]
		Пояснение: Т.к. у нас обертка csrf-токена (потому что используется ленивая инициализация [[#Как устроен CSRF Filter?]] `LazyCsrfTokenRepository`), то делегируется вызов на обычный `DefaultCsrfToken`:
		![[Pasted image 20240520145624.png]]
		в котором мы при создании обертку указали уже имя под которым должен лежать параметр в нашем запросе, содержащий crsf-токен:
		![[Pasted image 20240519220105.png]]
		![[Pasted image 20240520145800.png]]
		и мы возвращаем его

	2. `_csrf.token`:
		![[Pasted image 20240520145847.png]]
		Пояснение: Т.к. у нас обертка, то тут как раз происходит самое интересное:
		1. Сначала вызывается `saveTokenIfNecessary()`:
			![[Pasted image 20240520150021.png]]
			И вот как раз данный метод уже сохраняет наш токен.

			Сохранение происходит по средством вызова той реализации `CsrfTokenRepository`, которую мы передали в обертку.

			В нашем случае был передан `HttpSessionCsrfTokenRepository`:
			![[Pasted image 20240519220105.png]]
			и сохранение csrf-токена у нас будет происходить в атрибуты сессии:
			![[Pasted image 20240520150307.png]]

		2. После чего вызывается `this.delegate.getToken()`:
			![[Pasted image 20240520150413.png]]
			И здесь просто делегируется вызов нашему переданного в обертку сгенерированному `DefaultCsrfToken`:
			![[Pasted image 20240519220105.png]]
			из которого бы достаем UUID.

	 И вот как раз посредством такой логики:
	 ![[Pasted image 20240520150949.png]]
	 мы заполняем crsf-токен на нашей форме для запросов изменяющих состояние:
	 ![[Pasted image 20240520151025.png]]

	 И **САМОЕ ВАЖНОЕ** благодаря ленивой инициализации `LazyCsrfTokenRepository` и его обертки над токеном `SaveOnAccessCsrfToken` у нас при получении токена (т.е. когда он пригодился первый раз) в атрибуты сессии записывается crsf-токен, что позволяет теперь нам выполнить первое условие в [[#Как устроен CSRF Filter?]]:
	 ![[Pasted image 20240520151324.png]]

	 И далее мы уже сможем сравнить:
	 ![[Pasted image 20240520151603.png]]
	 в последующих запросах изменяющих состояние (т.е. например POST-запрос) их crsf-токен заполненный на форме:
	  ![[Pasted image 20240520151025.png]]
	  ![[Pasted image 20240520151540.png]]
	  с crsf-токеном, который лежит у нас в атрибутах сессии:
	  ![[Pasted image 20240520151446.png]]


- В случае если мы используем автозаполнение crsf-токена (т.е. `CsrfRequestDataValueProcessor`):
	![[Pasted image 20240520151710.png]]
	все аналогично, только будет вызван `CsrfRequestDataValueProcessor`:
	![[Pasted image 20240520151924.png]]
	1. Сначала из атрибутов запроса достаем нашу обертку токена `SaveOnAccessCsrfToken`:
		![[Pasted image 20240520151934.png]]

	2. Просто добавляем скрытый параметр crsf-токен (как в первом пункте):
		![[Pasted image 20240520152029.png]]
		- `token.getParameterName()` - аналогично:
			![[Pasted image 20240520152054.png]]

		- `token.getToken()` - аналогично:
			![[Pasted image 20240520152124.png]]

	и таким образом мы также заполнили crsf-токен на нашей формы для POST-запроса:
	![[Pasted image 20240520151710.png]]
	![[Pasted image 20240520151025.png]]

	и записали в атрибуты сессии наш crsf-токен что нам позволит сравнивать в последующих запросах crsf-токен пришедший с формы:
	![[Pasted image 20240520151025.png]]
	![[Pasted image 20240520151540.png]]
	с crsf-токеном, который лежит у нас в атрибутах сессии:
	![[Pasted image 20240520151446.png]]
	