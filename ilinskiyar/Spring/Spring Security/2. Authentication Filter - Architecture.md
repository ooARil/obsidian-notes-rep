Рассмотрим AuthenticationFilter:
![[Pasted image 20240430194615.png]]

---

### Модель хранения пользователя

Модель хранения пользователя - это информация о пользователе, который прошел аутентификацию:
![[Pasted image 20240430194807.png]]
Пояснение:
- SecurityContext - главный объект, в котором хранится информация о пользователе:
	![[Pasted image 20240430194842.png]]

- Authenticiation - на самом деле SecutiryContext представляет из себя просто обертку над Authenticiation объектом:
	![[Pasted image 20240430195001.png]]
	Пояснение:
	- Principal - по сути из себя представляет UserDto, т.е. это объект, который реализует интерфейс UserDetails и хранит всю информацию о нашем пользователе.
		Пояснение: Мы сами решаем, какую информацию о пользователе нам необходимо хранить)
		
	- Credentials - это пароль, который хранится ТОЛЬКО после **успешной аутентификации**
		Пояснение: чтобы не хранить попытки пользователя войти и чтобы пароль не гулял по нашему приложению) 
	
	- Authorities - это роли пользователя (их может быть много), они должны реализовывать интерфейс GrantedAuthorities (т.е. в нашем случае это обычный enum со значениями USER и ADMIN).
		Пояснение: Мы можем реализовывать какой угодно функционал, т.к. это просто интерфейс.

Для того, чтобы иметь доступ к нашему SecurityContext, который хранит в себе всю необходимую информацию о пользователе, - нужно использовать утилитный класс SecurityContextHolder:
![[Pasted image 20240430195624.png]]
Пояснение:
- В нем есть различные стратегии хранения SecurityContext, но самая распространенная (и которую использую) - это просто ThreadLocal (т.е. ключ - поток)
	Пояснение: Т.е. если нам будет необходимо получить SecurityContext текущего пользователя в HTTP-запросе, то будем обращаться к SecurityContextHolder.
		Т.е. как только пришел HTTP-запрос, то просто после удачной аутентификации пользователя кладем SecutiryContext в ThreadLocal переменную, - и как только закончится HTTP-запрос (т.е. когда ответ был отправлен) то просто чистим ThreadLocal.

---

### Как реализован AuthenticationFilter ?

![[Pasted image 20240430200139.png]]
Пояснение:
1. Создание Authenticiation-обеъкта:
	![[Pasted image 20240430195001.png]]
	![[Pasted image 20240430200743.png]]

2. Получение `AuthenticiationManager` и вызов метода `authenticate` с передачей в него `Authenticiation`-модели:
	![[Pasted image 20240430200801.png]]
	Пояснение: AuthenticiationManager из себя представляет просто for-each (т.е. он циклом проходится) по всем Authenticiation Provider (предоставление методов аутентификации)
		![[Pasted image 20240430200842.png]]
		For-each - потому что в приложении у нас может быть настроено несколько способов аутентификации.
		
	Замечание: Т.е. если у нас в приложении реализовано несколько способов аутентификации, то AuthenticiationManager будет проходиться по всем Authenticiation Provider и будет по очереди пытаться пройти аутентификацию.
		И как только первый из них успешно прошел - значит пользователь действительно есть в нашей системе и он успешно прошел аутентификацию.

---

### Пробный запуск без каких-либо настроек (просто на автоконфигурации)

При запуске контекста можно увидеть, чтобы создан пароль:
![[Pasted image 20240430201834.png]]
Это потому что в автоконфигурации в SecurityProperties ([[1. Security Starter#Подключение security-starter]]) в User стоит дефолтная настройка:
![[Pasted image 20240430145712.png]]

И как только мы в браузере заходим перейти на наш хост:
![[Pasted image 20240430202039.png]]

В дэбаге срабатывает doFilter в DelegatingFilterProxy:
![[Pasted image 20240430144408.png]]
![[Pasted image 20240430202130.png]]
Пояснение: В дэбаге мы видим следующее:
- И как раз можем увидеть наш FilterChain:
	![[Pasted image 20240430202258.png]]
	В котором нас интересует springSecurityFilterChain

- Также мы можем увидеть наш единственный DispatcherServlet:
	![[Pasted image 20240430202415.png]]
	которому пойдут все HTTP-запросы в приложении.

- И также мы видим Filter, которому будут делегироваться все наши запросы:
	![[Pasted image 20240430165242.png]]
	![[Pasted image 20240430202529.png]]
	И нас интересует filterChains, которая представляет из себя список. Но сейчас в ней задана по умолчанию только одна наша SecurityFilterChain:
	![[Pasted image 20240430202623.png]]
	в которой задано 15 фильтров для нашего Spring Security:
	![[Pasted image 20240430202657.png]]

	И как раз UsernamePasswordAuthenticationFilter мы будем использовать, чтобы пройти аутентификацию по логину и паролю:
	![[Pasted image 20240430202956.png]]

	Замечание: Кроме даже есть фильтр DafeultLoginPageGeneratingFilter, который предоставляет jsp-страничку для аутентификации по умолчанию (если у нас не определена своя).

И после прохождения всех фильтров мы видим нашу сгенерированную DafeultLoginPageGeneratingFilter страничку:
![[Pasted image 20240430203245.png]]
И видно, что у нас произошел redirect (перенаправление) с /users на /login:
![[Pasted image 20240430204540.png]]
потому что мы зашли под пользователем, которого не существует, - поэтому нас перенаправило на /login - что правильно.


Также помимо /login - есть и /logout страничка, по умолчанию предоставляемая фильтром DafeultLogoutPageGeneratingFilter:
![[Pasted image 20240430203746.png]]
![[Pasted image 20240430203803.png]]


Также можно увидеть, что сессия пользователя привязывается к Cookies:
![[Pasted image 20240430204001.png]]
Пояснение: 
- Т.е. JSESSIONID каждый раз отправляется на наш сервер (бэк). И на сервере храниться мапа всех JSESSIONID наших пользователей.
	И если в этой мапе будет пользователь по данной Cookie (т.е. JSESSIONID), то значит этот пользователь существует, и он уже прошел аутентификацию (и ему не нужно будет логиниться заново на каждый новый запрос).

- Поэтому если её удалить:
	![[Pasted image 20240430204319.png]]
	И попробую перейти на любую другую страничку:
	То сервер не находит в мапе пользователя по данному JSSESIONID и редиректит его на /login страничку для прохождения повторной аутентификации:
	![[Pasted image 20240430204440.png]]
	![[Pasted image 20240430204456.png]]