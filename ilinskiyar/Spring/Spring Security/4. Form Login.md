По правилам хорошего тона, мы должны поменять дефолтное страницу аутентификации, которую предоставляет DafeultLoginPageGeneratingFilter:
![[Pasted image 20240430203245.png]]
![[Pasted image 20240501141414.png]]
на свою собственную jsp-страницу.

---

### Реализация собственной login-формы

Собственная login форма:
![[Pasted image 20240501141641.png]]
Пояснение: Также у нас в ней есть кнопка Registration, - поэтому это еще одна причина почему дефолтная login-форма предоставляемая DafeultLoginPageGeneratingFilter нам не подходит.

---

### Подключение собственной login-формы к Spring Secuirty

1. Теперь из нашего старого контролера для login-страницы (когда еще не был подключен Spring Security):
	![[Pasted image 20240501141841.png]]
	необходимо удалить POST запроса /login - т.к. POST запрос с нашими входными данными будет принимать Spring Security:
	![[Pasted image 20240501141924.png]]
	Пояснение: Оставляем только GET который возвращает нашу форму.


2. Теперь чтобы определить нашу login-форму (user/login), чтобы на неё приходили POST-запросы с фронта, необходимо в SpringBootWebSecurityConfiguration:
	![[Pasted image 20240501142631.png]]
	переопределить данный дефолтный функционал:
	![[Pasted image 20240501142913.png]]
	Пояснение: В которой как раз таки и указывается `formLogin` - по умолчанию.

	Для этого наследуемся от WebSecurityConfigureAdapter и переопределяем метод configure, который принимает билдер HttpSecurity:
	![[Pasted image 20240501145822.png]]

	Пояснение: [[#Как вообще наследование от левого WebSecurityConfigurerAdapter переопределяет поведение? И что это вообще за поведение?]]

	Пояснение (про наши настройки):
	- `.authorizeRequests().anyRequest().authenticated()` - только пользователи, которые прошли аутентификацию могут зайти в приложение
	- `formLogin(login -> ...)` - принимает `Customizer<FormLoginConfigurer<HttpSecurity>>` в котором мы можем настроить нашу login-форму:
		- `loginPage("/login")` - URL по которому будет получена jsp-страница:
			![[Pasted image 20240501152432.png]]
		- `defaultSuccessUrl("/users")` - URL по которому будет получена jsp-страница, в случае успешной аутентификации (и это хорошо, потому что при дефолтной настройки нас кидало на / )
		- `permitAll()` - т.е. страница `/login` доступна всем пользователям (даже те, кто не прошли аутентификацию)

	- `.csrf().disable()` - отключаем CSRF.


Запускаем наш контекст и теперь видим нашу login-форму:
![[Pasted image 20240501152811.png]]
и после успешной аутентификации попадаем на users-форму:
![[Pasted image 20240501152902.png]]


--- 

### Как вообще наследование от левого WebSecurityConfigurerAdapter переопределяет поведение? И что это вообще за поведение?

Начнем с того, что такое HttpSecurity:
- `HttpSecurity` - это основной объект, используемый для настройки безопасности в Spring Security. Он позволяет определять, какие URL-адреса должны быть защищены, какие роли или права должны иметь пользователи для доступа к этим URL-адресам, и как пользователи должны аутентифицироваться.

	Он используется для:
	1. Определения URL-адресов, которые должны быть защищены (или не защищены).
	2. Определения login-форм и logout-форм.
	3. Определения методов аутентификации пользователей.
	4. Определения ролей или прав доступа, необходимых для доступа к защищенным URL-адресам.
	5. Определения стратегий обработки ошибок при доступе к защищенным URL-адресам.
	6. Определения механизмов защиты от атак, таких как Cross-Site Request Forgery (CSRF).


В SpringBootWebSecurityConfiguration определена дефолтная настройка:
	![[Pasted image 20240501142631.png]]
Пояснение:
- `.authorizeRequests().anyRequest().authenticated()` - только пользователи, которые прошли аутентификацию могут зайти в приложение
- `.formLogin()` - login-форма по умолчанию (т.е. срабатывает на /login - запрос + успешно аутентификации кидает на / + дэфолтная jsp-страница которую видели)
- `.httpBasic()`


И переопределить это поведение мы можем просто отнаследовавшись от WebSecurityConfigureAdapter и переопределить метод, принимающий как раз HttpSecurity-билдер:
![[Pasted image 20240501150452.png]]

Однако просто отнаследоваться мало, т.к. при запуске будет все равно создана дефолтная реализция:
![[Pasted image 20240501150527.png]]

А дело все в том, что наш класс должен являться бином, помеченным аннотацией @Configuration:
![[Pasted image 20240501150610.png]]
тогда будет срабатывать наша конфигурация:
![[Pasted image 20240501150643.png]]

А происходит это из-за @Conditional аннотации в SpringBootWebSecurityConfiguration:
![[Pasted image 20240501150731.png]]
если провалиться внутрь неё можно увидеть:
![[Pasted image 20240501151019.png]]
Пояснение: Т.е. как раз если мы определяем бин WebSecurityConfigureAdapter, то будет выключена дефолтная конфигурация:
![[Pasted image 20240501142631.png]]
и будет использоваться конфигурация WebSecurityConfigureAdapter с нашим переопределенным методом:
![[Pasted image 20240501150610.png]]


Замечание: Т.е. даже если не переопределять метод, а просто создать бин класса WebSecurityConfigureAdapter, то будет использоваться дефолтная настройка в нем:
![[Pasted image 20240501151252.png]]


---

### Почему Spring Security принимает /login запрос?

Потому что в HttpSecuirty стоит дефолтная настройка реста 

Либо где-то в кишках UsernamePasswordAuthenticationFilter стоит ожидание на "/login" - но я этого не увидел:
![[Pasted image 20240501160230.png]]

Кроме того необходимо передавать логин и пароль обязательно в таких полях как: username и password, потому что их ожидает на вход UsernamePasswordAuthenticationFilter.

Замечание: Но при желании это также можно переопределить.