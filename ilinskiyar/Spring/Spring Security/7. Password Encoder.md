Если мы храним пароли в базе данных, то у нас ВСЕГДА должен быть зашифрованный пароль (т.е. мы не сможем определить пароль пользователя, даже если у нас будет прямой доступ к базе данных).
Пояснение: Потому что это конфиденциальная информация.

Кроме того на самой форме пользователь будет вводить будет свой красивый пароль, а не зашифрованную его версию. Поэтому мы должны возможность зашифровывать пароль пользователя пришедший с фронта с зашифрованным паролем в бд для прохождения аутентификации.

Поэтому нам необходим Password Encoder.

Замечание: Поэтому в [[4. DaoAuthenticationProvider]] в реализации UserDetailsService мы передавали только username (а не по зашифрованному password):
![[Pasted image 20240502004044.png]]
потому что как раз таки внутри Authentification Providers происходит сравнение зашифрованных паролей:
![[Pasted image 20240502004447.png]]
![[Pasted image 20240502004845.png]]
	Пояснение: Вот тут как раз с помощью Password Encoder (и его метода matches) идет сравнения пароля из объекта Authentication (т.е. данные с фронта) с паролем из базы.

---

### Что такое Password Encoder?

Password Encoder в Spring Security - это интерфейс, который используется для кодирования паролей пользователей перед их сохранением в базе данных или перед сравнением с паролем, введенным пользователем во время входа.

Он нужен для следующих целей:
1. **Безопасность**: Пароли должны быть зашифрованы, чтобы их нельзя было прочитать, если в базе данных будет взломан.
    
2. **Проверка пароля**: Когда пользователь вводит пароль для входа, он должен быть сравнен с зашифрованным паролем, хранящимся в базе данных. PasswordEncoder используется для этого.
    
3. **Уникальность**: Для каждого пользователя должен быть уникальный зашифрованный пароль, чтобы нельзя было просто сравнить зашифрованные пароли друг с другом.

Виды Password Encoder-ов, которые поддерживаются в Spring Security:
![[Pasted image 20240502005556.png]]
Пояснение: Как раз среди них можно увидеть наш префикс {noop}, который мы проставляли в [[4. DaoAuthenticationProvider#Реализация аутентификации на основе DaoAuthenticationProvider]]]:
	![[Pasted image 20240501011541.png]]

---

Короткие заметки

Ну короче да, там в DaoAuthenticationProvider внутри определен декодер DelegatingPasswordEncoder, содержит в себе мапу декодеров, и в методе сравнения шифрованных паролей, он по стратегии вызывает нужный делегеатор декодер на основании префикса { } зашифрованного пароля.

И у этого DelegatingPasswordEncoder дефолтным декодером для кодировки является Bcrypt
