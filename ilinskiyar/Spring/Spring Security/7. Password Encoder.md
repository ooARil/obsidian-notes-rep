Если мы храним пароли в базе данных, то у нас ВСЕГДА должен быть зашифрованный пароль (т.е. мы не сможем определить пароль пользователя, даже если у нас будет прямой доступ к базе данных).
Пояснение: Потому что это конфиденциальная информация.

Кроме того на самой форме пользователь будет вводить будет свой красивый пароль, а не зашифрованную его версию. Поэтому мы должны возможность зашифровывать пароль пользователя пришедший с фронта с зашифрованным паролем в бд для прохождения аутентификации.

Поэтому нам необходим Password Encoder.

Замечание: Поэтому в [[4. DaoAuthenticationProvider]] в реализации UserDetailsService мы передавали только username (а не по зашифрованному password):
![[Pasted image 20240502004044.png]]
потому что как раз таки внутри Authentification Providers происходит сравнение зашифрованных паролей:
![[Pasted image 20240502004447.png]]
![[Pasted image 20240502004845.png]]
	Пояснение: Вот тут как раз с помощью Password Encoder (и его метода matches) идет сравнения пароля из объекта Authentication (т.е. данные с фронта) с паролем из базы.

---

### Что такое Password Encoder?

Password Encoder в Spring Security - это интерфейс, который используется для кодирования паролей пользователей перед их сохранением в базе данных или перед сравнением с паролем, введенным пользователем во время входа.

Он нужен для следующих целей:
1. **Безопасность**: Пароли должны быть зашифрованы, чтобы их нельзя было прочитать, если в базе данных будет взломан.
    
2. **Проверка пароля**: Когда пользователь вводит пароль для входа, он должен быть сравнен с зашифрованным паролем, хранящимся в базе данных. PasswordEncoder используется для этого.
    
3. **Уникальность**: Для каждого пользователя должен быть уникальный зашифрованный пароль, чтобы нельзя было просто сравнить зашифрованные пароли друг с другом.

Виды Password Encoder-ов, которые поддерживаются в Spring Security:
![[Pasted image 20240502005556.png]]
Пояснение: Как раз среди них можно увидеть наш префикс {noop}, который мы проставляли в [[4. DaoAuthenticationProvider#Реализация аутентификации на основе DaoAuthenticationProvider]]]:
	![[Pasted image 20240501011541.png]]

Т.е. именно на основании этих префиксов у нас определяется, какой Password Encoder нужно использовать, чтобы дешифровывать и сравнивать пароли.
Пояснение: Поэтому в [[4. DaoAuthenticationProvider]] определен DelegatingPasswordEncoder:
![[Pasted image 20240505042408.png]]
	для универсальности ([[#Что из себя представляет DelegatingPasswordEncoder?]])


---

### Что из себя представляет DelegatingPasswordEncoder?

DelegatingPasswordEncoder - предоставляется фабрикой PasswordEncoderFactories:
![[Pasted image 20240505044550.png]]

DelegatingPasswordEncoder - хранит в себе мапу всех поддерживаемых Password Encoder-ров в Spring:
![[Pasted image 20240505042629.png]]

Как работает DelegatingPasswordEncoder:
- При сравнении пароля пришедшего с фронта (который ввел пользователь - т.е. Authentication) с зашифрованным паролем UserDetails (в нашем случае сохраненным в базе данных):
	![[Pasted image 20240505043133.png]]
	- Authentication:
		![[Pasted image 20240505043206.png]]
	- UserDetails:
		![[Pasted image 20240505043243.png]]
	
	вызывается метод matches:
	![[Pasted image 20240505043458.png]]
	в котором просходит следующее:
	1. Сначала из зашифрованного пароля UserDetails достается префикс, для определения алгоритма, по которому был зашифрован пароль:
		![[Pasted image 20240505043716.png]]
	2. После чего из мапы encoders по префиксу, достается реализация PasswordEncoder-а, с помощью которого был зашифрован пароль:
		![[Pasted image 20240505043846.png]]
		![[Pasted image 20240505043857.png]]
		![[Pasted image 20240505043808.png]]
		![[Pasted image 20240505044126.png]]
	3. Далее у зашифрованного пароля UserDetails убирается префикс:
		![[Pasted image 20240505043955.png]]
	4. После чего по нужной реализации PasswordEncoder вызывается метод сравнения пароля пришедшего с фронта (который ввел пользователь - т.е. Authentication) с зашифрованным паролем:
		![[Pasted image 20240505044111.png]]
		![[Pasted image 20240505044131.png]]
		![[Pasted image 20240505044144.png]]

		Таким образом **DelegatingPasswordEncoder предоставляет универсальный функционал по сравнению шифрованных паролей на основании префиксов зашифрованных паролей** (поэтому как раз таки данная реализация PasswordEncoder используется в  [[4. DaoAuthenticationProvider]])

- А в случае шифрования пароля у DelegatingPasswordEncoder используется тот PasswordEncoder, чей префикс мы укажем в конструкторе.
	Пояснение: Т.е. в случае PasswordEncoder-а предоставляемого фабрикой PasswordEncoderFactories:
	![[Pasted image 20240505044731.png]]
	![[Pasted image 20240505044737.png]]
	![[Pasted image 20240505044753.png]]
	![[Pasted image 20240505044815.png]]
	Таким образом в DelegatingPasswordEncoder предоставляемого фабрикой в качестве реализации PasswordEncoder будет выступать `BCryptPasswordEncoder`.

	
---

### Реализация формы регистрации пользователей с помощью PasswordEncoder

PasswordEncoder нам необходим, если мы хотим создавать нашего пользователя вручную через страницу.
Пояснение: Потому что нам нужно шифровать пароли.

Реализация:
1. PasswordEncoder не является бином, поэтому для начала создадим бин  DelegatingPasswordEncoder:
	![[Pasted image 20240505050046.png]]
	Пояснение: 
	- Т.е. будем использовать создание DelegatingPasswordEncoder из фабрики PasswordEncoderFactories.
	- Т.е. по умолчанию для шифрования паролей у нас будет реализация PasswordEncoder - `BCryptPasswordEncoder`.

2. Добавим возможность при создании нового пользователя вводить пароль:
	![[Pasted image 20240505050339.png]]
	
3. Добавляем сохранение пароля пользователя в базу данных, предварительно зашифрованным с помощью нашего бина PasswordEncoder:
	![[Pasted image 20240505050658.png]]
	![[Pasted image 20240505050913.png]]
	Пояснение: Т.е. теперь в сущность User из нашей DTO которая приходит с фронта (т.е. UserCreateEditDto) в базу данных пароль будет записывать в зашифрованном виде (зашифрованным с помощью `BCryptPasswordEncoder`):
		![[Pasted image 20240505051130.png]]

Запускаем и проверяем:
![[Pasted image 20240505053350.png]]
![[Pasted image 20240505053519.png]]
![[Pasted image 20240505053526.png]]
Пояснение: 
- Создал пользователя с паролем 12345.
- И т.е. видно, что с помощью нашего DelegatingPasswordEncoder пароль 12345, был зашифрован и сохранен в базу данных с помощью `BCryptPasswordEncoder` ([[#Что из себя представляет DelegatingPasswordEncoder?]])

И теперь попытаемся авторизоваться:
![[Pasted image 20240505053657.png]]
![[Pasted image 20240505053725.png]]
Пояснение:
- Т.е. при введеном пароле 12345 (а не в зашифрованном в виде) с помощью DelegatingPasswordEncoder он был успешно сверен с зашифрованным паролем из базы данных - потому что DelegatingPasswordEncoder по префиксу зашифрованного пароля:
	![[Pasted image 20240505053526.png]]
	был вызван  `BCryptPasswordEncoder` ([[#Что из себя представляет DelegatingPasswordEncoder?]])
