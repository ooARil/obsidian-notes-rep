JUnit тесты уровня - @Repository
![[Pasted image 20230925083016.png]]
Он не должен подключаться к реальной базе данных, - лучшим решением будет подключение к H2 бд

@DataJpaTest:
* Автоматически настраивает базу данных (в нашему случае H2 база) в памяти для тестирования.
* Не загружает в контекст Spring-а бины: @Controller, @Service и т.д. Аннотация для JPA-теста, который фокусируется только на компонентах JPA (т.е. на Entity (@Entity) и Mapper JPA (@Repository) классах)
* По умолчанию тесты, помеченные @DataJpaTest, являются транзакционными и откатываются в конце каждого теста. Они также используют встроенную базу данных в памяти (заменяющую любой явный или обычно автоматически настраиваемый источник данных)
	* Чтобы отключить откат транзакции для определенного теста можно использовать аннотацию @RollBackTest

С помощью аннотации @DataJpaTest можно не только тестировать Repository, но и компоненты связанные с JPA:
* DataStource - часть Spring
* JdbcTemplate - часть Jdbc
* EnityManager - часть JPA
* UserRepository - часть JPA
![[Pasted image 20230925091639.png]]

----

Пример тест:
! Обрати внимание на BDD стиль
![[Pasted image 20230926074826.png]]
* @DisplayName - аннотация, которая позволяет задать имя теста, которое будет отражаться при тестировании:
![[Pasted image 20230926074919.png]]

Рефакторинг:
* @BeforeEach - аннотация, которая позволяет вынести повторяющийся код в отдельный метод, который будет вызываться перед каждым junit-тестом:
![[Pasted image 20230926090330.png]]

Также можно вызвать весь класс тестов:
![[Pasted image 20230926090556.png]]
! Тесты не будут друг другу мешать, т.к. каждый тест помеченный аннотацией @Tets выполняет в отдельной транкзации, после чего откатывает её

-----
JUnit тесты уровня - @Service
![[Pasted image 20230927071939.png]]
В этом случае нам нужно будет мокетировать beans @Repository для этого нужно использовать framework Mokito
* Mockito - это framework Java, который мы можем использовать для имитации зависимостей.

-----------
Несколько терминов:
* Class under Test - класс, который мы хотим протестировать
![[Pasted image 20230927073749.png]]

* Method under Test - метод, который мы хотим протестировать
![[Pasted image 20230927073824.png]]

---------------
Несколько методов framework Mockito:
* mock() - можно использовать статический метод класс Mockito для создания имитации объекта, передав в него класс или интерфейс
![[Pasted image 20230927073934.png]]
* @Mock - можно использовать аннотацию. Это удобнее если мы хотим использовать имитацию зависимости в нескольких местах, т.к. мы избегаем многократного вызова метода mock(). Кроме того код становится более читаемым, и мы можем там имитируемой завимости имя, что облегчит поиск ошибок.
![[Pasted image 20230927074101.png]]
* @InjectMocks - если мы хотим внедрить мокитированный объект, в другой объект, то мы можем использовать аннотацию @InjectMocks. Т.е. с помощью аннотации @InjectMocks создается экземпляр класса, и в этот объект внедряются все зависимости помеченные аннотацией @Mock.
![[Pasted image 20230927074642.png]]

Mockito framework предоставляет класс BDDMockito, который мы можем использовать для написания модульных тестов в стиле BDD:
![[Pasted image 20230927074952.png]]
! Обрати внимание на статический метод given() и willReturn() класса BDDMockito

---------
Продолжение JUnit тестирования - уровень @Service

Пример модульного теста уровня @Service - в котором тестирую метод saveEmployee(), в котором используется зависимость EmployeeRepository уровня @Repository:
* Вызов метода findByEmail()
* Вызов метода save()
![[Pasted image 20230927085408.png]]

Описание JUnit теста:
![[Pasted image 20230927085126.png]]
![[Pasted image 20230927090242.png]]
1. *@BeforeEach*: Сначала в методе setup() - был создан mock объекта EmployeeRepository и после чего этот mock объект был передан в конструктор EmployeeService (таким образом была добавлена имитация зависимости)
2. *GIVEN*: После чего в статический метода given() класса BDDMockito был передан метод класса EmployeeRepository, который вызывается в тестируемом метод. Чтобы сделать заглушку этого метода, в wiilReturn() был указан его возвращаемый результат: 
	- Это можно увидеть в отладке:
	  Т.е. вот здесь видно, что в mock объекте EmployeeRepository в вложенном объекте stubbed хранятся все "заглушки-методы" и их "заглушки-ответы"
	  ![[Pasted image 20230927085043.png]]
	  ![[Pasted image 20230927090122.png]]
3. *WHEN* : После этого вызывается тестируемый метод (Methon under Test)
4. *THEN* : Проверяется полученный результат метода
5. Результат:
   Тест пройден + мы видим, что создался mock объект и он не null
   ![[Pasted image 20230927090524.png]]

-------------------
Рефакторинг:
* Вместо использования статического метода mock() класса Mockito, используем аннотации @Mock и @InjectMocks:
	* @Mock - создает макет.
	* @InjectMocks - создает экземпляр класса и внедряет в этот экземпляр макеты, созданные с помощью аннотаций @Mock. 
		! Но не помещает его в контекст Spring! Т.е. не регистрирует объект как bean.
	* @ExtendWith(MocktoExtension.class) - аннотация используется для загрузки расширения JUnit 5. JUnit определяет API расширения, который позволяет стороннему поставщику, такому как Mockito, подключаться к жизненному циклу запущенных тестовых классов и добавлять дополнительную функциональность. `MockitoExtension` просматривается тестовый класс, находит переменные-члены, снабженные `@Mock` аннотацией, и создает макет реализации этих переменных. Затем он находит переменные-члены, помеченные `@InjectMocks` аннотацией, и пытается внедрить свои mocks в эти классы, используя либо инъекцию конструкции, либо инъекцию setter .
! https://www.arhohuttunen.com/junit-5-mockito/ - в этой ссылке указывается для чего используется расширение MocktoExtension.class (p.s. В JUnit 5 используется для упрощение создания экземпляра класса и инжекта в него макетной зависимости)
![[Pasted image 20230928080808.png]]

---
Проверка выброса исключений с помощью Mockito:
![[Pasted image 20231001082805.png]]
* *GIVEN*: given(employeeRepository.save(employee)).willReturn(employee) - закомментирован, т.к. данная заглушка не используется, т.е. в рамках этого теста данный заглушечный метод не был бы вызван - поэтому если раскомментировать, то будет исключение UnnecessaryStubbingException.
* *WHEN* : assertThrows() - проверяет было ли выброшено исключение - хоть это и проверка, но данный вызов используется в блоке when, - т.к. мы проверяем, что из-за выброшенного исключения, не был вызван метод employeeRepository.save(employee).
* *THEN* : verify(employeeRepository, never()).save(any(Employee.class)) - используется для проверки вызова методов объекта, который был создан с помощью Mockito. В данном примере строка кода проверяет, что метод save() объекта employeeRepository никогда не был вызван с любым объектом класса Employee в качестве параметра.
	* В качестве аргументов для статического метода verify() также можно передавать следующие статические методы:
		1. times(int n) - проверяет, что ожидаемый вызов метода произошел ровно n раз.
		2. atLeast(int n) - проверяет, что ожидаемый вызов метода произошел как минимум n раз.
		3. atMost(int n) - проверяет, что ожидаемый вызов метода произошел не более n раз.
		4. only() - проверяет, что ожидаемый вызов метода произошел только один раз.
		5. never() - как уже было упомянуто, проверяет, что ожидаемый вызов метода не был произведен ни разу.

-------
Пример тестирования негативного сценария:
![[Pasted image 20231001085255.png]]

----
Проверка методов, которые возвращают void:
* Если метод возвращает void, то нужно использовать статический метод willDoNothing().
![[Pasted image 20231001091405.png]]
! Статический метод willDoNothing() фреймфорка Mockito используется для создания заглушки (mock) объекта, который не будет выполнять никаких действий при вызове определенного метода. То есть, данный метод позволяет нам указать, что при вызове определенного метода объекта, мы не хотим, чтобы он выполнял какие-либо действия.
! Если метод объекта mock возвращает какое-либо значение, то использование статического метода willDoNothing() не имеет смысла, так как он будет перезаписывать любое заданное поведение для данного метода.

------
JUnit тесты - уровня @Controller:
* В этом случае мы будет же мокать объект уровня Service Layer (@Service)
* Чтобы использовать только компоненты уровня @Controller нужно использовать аннотацию @WebMvcTest (т.е. данная аннотация не поднимает контекст и соответственно не инжектит такие компоненты как @Service и @Repository, - а только загружает необходимые компоненты на уровне @Controller)
![[Pasted image 20231001111010.png]]

Синтаксис:
![[Pasted image 20231001112521.png]]

--------
Подробнее об аннотации @WebMvcTest
* @WebMvcTest - аннотация, которая позволяет создать тестовое окружение для тестирования MVC-контроллеров без необходимости запускать весь контекст приложения. 
* Использование этой аннотации отключит полную автоматическую настройку и вместо этого применит только конфигурацию, относящуюся к тестам MVC (т.е. компоненты @Controller, @ControllerAdvice, @JsonComponent, Converter/GenericConverter, Filter, WebMvcConfigurer и HandlerMethodArgumentResolver, но не компоненты @Component, @Service или @Repository).
* Также мы можем указать конкретный @Controller, который мы хотим тестировать @WebMvcTest(EmployeeController.class), - чтобы инжектить только те компоненты, которые связаны с EmployeeController бином.
![[Pasted image 20231001113929.png]]

-----
@WebMvcTest vs @SpringBootTest

* @WebMvcTest:
	* В контекст Spring загружает только те bean-компоненты, которые требуются для тестирования MVC-контроллеров (т.е. @Controller, @ControllerAdvice и т.д.)
	* JUnit (модульные) тесты
	* Ускоряет тестирование уровня @Controller, так как тянет только зависимости уровня @Controller
* @SpringBootTest:
	* Поднимает весь контекст приложения (т.е. все компоненты Spring).
	* Integration (интеграционные) тесты
------
Продолжение JUnit тестирования - уровень @Controller

Описание JUnit теста:
![[Pasted image 20231009083747.png]]
* MockMvc - это основной класс в Spring MVC Test Framework, который предоставляет мощные функции для тестирования веб-приложений. Он предоставляет набор методов для выполнения HTTP-запросов к контроллерам в вашем приложении, а также для проверки ответов от них. MockMvc позволяет имитировать запросы к серверу без необходимости развертывать реальный сервер.
* @MockBean - позволяет создать и внедрить мок-объект (mock object) для определенного бина в контексте Spring для использования в тестах.

---
Разница между @Mock и @MockBean:
Разница между @Mock и @MockBean заключается в том, что @Mock является аннотацией библиотеки Mockito и используется для создания мок-объекта без его регистрации в контексте Spring, в то время как @MockBean является аннотацией Spring и помимо создания мок-объекта также регистрирует его в контексте Spring.

! При этом @Mock в связке с @InjectMocks также не создает bean:
	@InjectMocks не создает полноценный Spring бин, она просто создает объект и внедряет в него зависимости с помощью рефлексии (через конструктор, сеттеры или напрямую в поля), без учета всей полноты функционала, предоставляемого Spring (такого как управление жизненным циклом бина, применение аспектов и т.д.)

---

Продолжение JUnit тестирования - уровень @Controller
![[Pasted image 20231009083115.png]]
* *GIVEN* : 
	* *given(employeeService.saveEmployee(any(Employee.class)))* - Это часть, которая говорит Mockito ожидать вызов метода saveEmployee с любым аргументом типа Employee.
	* *.willAnswer((invocation) -> invocation.getArgument(0));* - это часть, которая определяет, что должно произойти, когда метод saveEmployee вызывается. В данном случае, он будет возвращать аргумент, который был передан в метод (т.е., объект Employee), без каких-либо изменений.
* *BEFORE* :
	* *perform* - позволяет тестировать http-запросы не поднимая реальный сервер.
	* *perform* в качестве параметра принимает интерфейс RequestBuilder. Один из экземпляров это MockMvcRequestBuilders - это класс в библиотеке Spring MVC Test, который предоставляет статические методы для создания запросов к контроллерам во время тестирования. Этот класс позволяет создавать различные типы запросов (GET, POST, PUT, DELETE) и настраивать их параметры, такие как пути, заголовки, тело запроса и другие.
* *THEN*:
	* ResultActions - это класс в библиотеке тестирования Spring MVC, который предоставляет методы для проверки результатов выполнения запросов к контроллеру Spring MVC:
		* andDo(ResultHandler) - используется для добавления дополнительных действий, которые будут выполнены над результатом запроса. Эти действия могут быть использованы для записи логов, проверки состояния ответа или выполнения других пользовательских операций. (например print() - выводит результат запроса-ответа в консоль)
			![[Pasted image 20231206224849.png]]
		* andExpect(ResultMatcher) - используется для сравнения ожидаемого результата с фактическим результатом. Если различие (используется assertEquals()), то выбрасывается исключение.

-------------
