Очень информативный сайт про интеграционные тесты:
https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/html/boot-features-testing.html

Об аннотации @SpringBootTest

![[Pasted image 20231217150718.png]]

В отличие от модульных тестов, при интеграционном тесте с помощью аннотации @SpringBootTest у нас поднимется контекст, и все бины в этих слоях загрузятся в контекст Spring и будут нам доступны.

Поэтому при интеграционном тестировании нам не нужно использовать Mockito, т.к. нам не нужно мокать (делать заглушки) зависимости.

Что включает в себя аннотация @SpringBootTest:
1. ApplicationContext для вашего теста. Она сканирует ваше приложение и создает контекст, включая все бины и компоненты, необходимые для его функционирования.
    
2. **Включение полного приложения:** Тесты с использованием `@SpringBootTest` могут включать весь ваш Spring-приложение. Это означает, что они могут тестировать взаимодействие между различными слоями приложения, включая контроллеры, сервисы, репозитории и т.д.
    
3. **Настройка контекста:** Вы можете настраивать контекст теста, указывая различные параметры, такие как классы конфигурации, активные профили, и т.д.

---

Настройка контекста с помощью аннотации @SpringBootTest

Некоторые из основных параметров:
1. **classes:** С помощью параметра `classes` вы можете указать классы конфигурации, которые должны быть загружены в контекст теста. Например:

```java
@SpringBootTest(classes = { AppConfig.class, TestConfig.class })
```

		Пояснение: Параметр `classes` в аннотации`@SpringBootTest` предназначен для указания классов конфигурации Spring, которые должны быть загружены при инициализации контекста теста. Эти классы обычно содержат настройки и бины, необходимые для правильного функционирования вашего приложения в тестовом окружении.
			Если класс не указан, то будет использован *класс по умолчанию*, который помечен аннотацией @SpringBootApplication.

2. **properties:** Вы можете использовать параметр `properties`, чтобы определить свойства приложения, которые должны быть установлены для теста:

```java
@SpringBootTest(properties = { "app.timeout=5000", "app.debug=true" })
```

3. **webEnvironment:** Параметр `webEnvironment` позволяет настроить окружение для тестов, связанных с веб-приложениями. Этот параметр имеет различные варианты, такие как `MOCK`, `RANDOM_PORT`, `DEFINED_PORT`, и `NONE`

---

Настройка propertiest (свойств) для тестов

В Spring Framework существует несколько способов добавления переменных (свойств) в контекст приложения. Одним из таких способов является использование файла свойств (`application.properties` или `application.yml`). 
Однако, для интеграционных тестов, когда требуется определенная конфигурация, можно использовать аннотации или параметры аннотации `@SpringBootTest` для явного задания свойств. Вот несколько способов:

1. Параметр **properties** в аннотации @SpringBootTest:
``
```java
@SpringBootTest(properties = {"app.name=TestApp", "app.version=2.0"})
public class YourIntegrationTest {
    // ваш тестовый код
}
```

2. Указать их в файлах application.yml (application.properties)

	
3. С помощью аннотации @TestPropertySource можно указать файл свойств

```java
@SpringBootTest
@TestPropertySource(locations = "classpath:test-application.properties")
public class YourIntegrationTest {
    // ваш тестовый код
}

```

		Пояснение: Это может быть полезно если мы называем файл не по-умолчанию.

4. Параметры профиля @SpringBootTest

```java
@SpringBootTest
@ActiveProfiles("test")
public class YourIntegrationTest {
    // ваш тестовый код
}

```

		Пояснение: Если несколько файлов свойств, у которых через "-" указан профиль (т.е. например application-test.yml), то для теста можно указать конкретный профиль.

---

Настройка webEnviroment (окружения) для тестов

Параметр `webEnvironment` в аннотации `@SpringBootTest` определяет, каким образом должно быть настроено веб-окружение для интеграционного тестирования.

Варианты:
1. **MOCK (по умолчанию):** Это вариант используется для тестирования веб-контекста с использованием встроенного в Spring MockMvc. Он не запускает встроенный сервер.

```java
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
```

* Пояснение:
	* Описание: В этом режиме тестирования используется встроенная возможность Spring MockMvc для тестирования веб-контроллеров и взаимодействия с приложением, не запуская реальный веб-сервер.
	- **Ситуации использования:**
		-  Когда вам нужно протестировать взаимодействие с контроллерами без реального запуска веб-сервера.
		- Когда вам не требуется тестировать низкоуровневые детали веб-сервера (т.е. например нам не нужна кафка и т.д., чтобы инстанс приложение не поднимался).
	- Интересный момент: Если в приложении используется feign клиент и eureka, то из-за т.к. MockMvc поднимает контект, но не поднимаем сервер, но при этом каким-то образом умудряется регистрироваться в eureka, и из-за это feign запросы работают.

 2. **RANDOM_PORT:** Запускает приложение на случайном порту. Полезно для тестирования взаимодействия с реальным веб-сервером.
	   
	```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
```

* Пояснение:
	* Описание: Запускает приложение на случайном порту, что позволяет тестировать взаимодействие с реальным веб-сервером.
	* **Ситуации использования:**
		*  Когда вам нужно тестировать интеграцию между компонентами, работающими на разных портах.
		- Когда вам нужно тестировать конфигурацию с реальным веб-сервером (т.е. когда нам нужно поднять инстанс приложения).

3. **DEFINED_PORT:** Запускает приложение на определенном порту. Позволяет указать конкретный порт для тестирования.
	   
```java
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
```


4. **NONE:** Запускает приложение без встроенного веб-сервера. Используется, когда тесты не требуют веб-контекста.
	   
	```java
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
```
	

---

Как webEnviroment влияет на транкзации:

Если ваш тест является `@Transactional`, он по умолчанию откатывает транзакцию в конце каждого метода тестирования. 

! Однако при использовании этого механизма с любым `RANDOM_PORT` или `DEFINED_PORT` неявно обеспечивается реальная среда сервлета, HTTP-клиент и сервер выполняются в отдельных потоках и, следовательно, в отдельных транзакциях. **Любая транзакция, инициированная на сервере, в этом случае не откатывается**.

---

Аннотация @AutoConfigureMockMvc

```java
@SpringBootTest
@AutoConfigureMockMvc
public class YourIntegrationTest {
    @Autowired
    private MockMvc mockMvc;

    // Ваш тестовый код
}
```

- **Сфера применения:** Используется в интеграционных тестах для тестирования взаимодействия различных слоев веб-приложения, включая контроллеры, сервисы и репозитории.
- **Автоконфигурация:** Аннотация `@AutoConfigureMockMvc` настраивает объект `MockMvc` в тестовом контексте, но не ограничивается только настройкой веб-слоя. Она также поддерживает автоконфигурацию других компонентов, таких как сервисы и репозитории.

---

Пример интеграционного теста:

![[Pasted image 20231218203309.png]]
![[Pasted image 20231218203328.png]]

---

@AutoConfigureTestDatabase

`@AutoConfigureTestDatabase` в Spring Boot предоставляет возможность автоматической настройки базы данных при выполнении тестов. 

```java
@DataJpaTest  
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)  
public class EmployeeRepositoryITests {  
  
    @Autowired  
    private EmployeeRepository employeeRepository;
    
}
```

Эта аннотация позволяет определить, какую базу данных следует использовать в тестовом контексте, и предоставляет различные опции для этой настройки. Она часто используется вместе с аннотациями тестирования базы данных, такими как `@DataJpaTest`, `@WebMvcTest` и другими.

Возможные значения параметра `replace`:

1. **AutoConfigureTestDatabase.Replace.NONE:** Не производить замену конфигурации базы данных. Использовать настройки, определенные в вашем приложении.

		Пояснение: Т.е. @DataJpaTest поднимает контекст Spring и добавляет настройки и завимости только связанные с БД, то можно в application.yml указать кокретные настройки, и если не указать NONE то данная конфигурация не будет использована (а будет использована например H2 база)

2. **AutoConfigureTestDatabase.Replace.AUTO_CONFIGURED:** Автоматически определить настройки базы данных для тестов на основе имеющихся конфигураций. Обычно используется для автоматического замещения реальной базы данных на фиктивную или в памяти базу данных.
      
3. **AutoConfigureTestDatabase.Replace.ANY (по умолчанию):**  Заменить любую настройку базы данных на фиктивную или в памяти базу данных. Используется для явной замены любой конфигурации.